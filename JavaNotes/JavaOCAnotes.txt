Chapter 1 [Java Building Blocks] ::
    PDF Page: 47
    Understanding the Java Class Structure ::
        Fields and Methods ::
            -> Java classes have two primary elements ::
                ->_> methods, often called functions or procedures in other languages
                    <-> A method is an operation that can be called
                    <-> methods operate on the state of the program
                    <-> Methods can require information to be supplied called a parameter
                ->-> fields, more generally known as variables
                    <-> variables hold the state of the program
                ***Together these are called the members of the class***-
            >-> Method Signature ::
                public              int            getName          (int l)
                [access modifier]   [return type]  [method name]    [parameter(optional)]
                <-> altogether it looks like -> public int getName(int l){} 
            -> The different Comment types ::
                    two backslashes // will comment until the end of the line it is on
                    /* */ will comment anything inbetween the /* */ called a multiple-line comment
                    /** */ similar to the multiple line comment but tells the Javadoc to pay attention to the comment 
                                this means that the Javadoc tool can read it
        Classes vs. Files ::
            ->-> Normally, each Java class is defined by its own .java file
            ->-> Classes do not have to be public AND you can have multiple classes in one file 
                 BUT 
                 at most only ONE of those classes can be public
                 ->-> the public class needs to match the filename (the file's name)
        Writing a main() Method ::
            ->-> public static void main(String[] args){}
                 is the entry point between the startup of a Java process 
                        and the beginning of the programmer's code
            ->-> to compile and execute this code you would write (in the terminal)
                 javac fileName.java // this compiles it
                 java fileName // this executes it 
            _>-> if a main() method isn't in the class with the .java executable then 
                            the process will throw an error and terminates
                    even if it is present, an exception will be thrown if the main() is not static
            ->-> keyword void represents the return type,  
                 good practice to use these types of methods when changing an object's state
            ->-> the parameter portion of the main() method can look like 
                        (String[] args) , (String args[]) ,and (String...args)
            ->-> you can have the main() print (args[index]) which , to run, 
                 type 
                    javac filename.java
                    java filename argument
                 it'll print argument if we choose 0 as an index since that is the first index after the file's name 
                 <-> spaces are used to separate arguements
                 <-> to have spaces inside arguments you would use quotes, "arguem ent" 
                 <-> all command-line arguments are treated as String objects
    Understanding Package Declarations and Imports ::
        ->-> Package names are hierarchical, you start reading a package name at the beginning 
             <-> if it begins with java or javax, this means it came with the JDK. 
                  If it starts with something else, it likely shows where it came from using the website name in reverse.
        Wildcards ::
            ->-> when doing imports, the asterisk, * , is a wildcard that mtaches all classes in the package
                 Ex.) import java.util.*; 
            ->-> wildcards only match class names
        Redundant Imports ::
            ->-> import java.lang is redundant because it is automatically imported
            ->-> all redundant imports means any import that goes unused or is unnecessary within the context of the code
            ->-> imports that don't work are ones that have more wildcards than necessary, as well as being in the wrong place,
                    <-> attempting to use wildcards on imports without getting specific enough to * the classes
                    <-> you CANNOT import methods, only class names
        Naming Conflicts ::
            ->-> when a class is found in multiple different packages, 
                    it won't compile if you try and import all of the packages it is from 
            ->-> You can specify one package all the way to the class and 
                    the other one can be general if you need other imports from a package that contains a duplicate class name
                 <-> Explicitly importing a class name takes precedence over any wildcards present
                 <-> Ex.) import java.util.Date; 
                          import java.sql.*;     // both of these compile
                     Ex.) import java.util.*; 
                          import java.sql.*;  // this does not compile
            ->-> If you really need a class from two different packages with the SAME name 
                    pick one to import and the other can be used through its imported name 
                    <-> Ex.) import java.util.Date;
                             
                             public class Conflicts{
                                Date date; 
                                java.sql.Date sqlDate; // this is called the fully qualified class name; 
                             }      
        Creating a New Package :: 
            ->-> the default package is a special unnamed package that doesn't have a package name
            ->-> making files, compiling them, 
                  <-> Windows Setup
                        Create the two files:
                            ■ C:\temp\packagea\ClassA.java
                            ■ C:\temp\packageb\ClassB.java
                        Then type this command:
                            cd C:\temp
                  <-> Mac/Linux Setup
                        Create the two fi les:
                            ■ /tmp/packagea/ClassA.java
                            ■ /tmp/packageb/ClassB.java
                        Then type this command:
                            cd /tmp
                  To Compile Type this command:
                        javac packagea/ClassA.java packageb/ClassB.java
                  If this command doesn’t work, you’ll get an error message. 
                  Check for typos against the provided files.
                  If the command does work, two new files will be created:
                        packagea/ClassA.class and packageb/ClassB.class.
                  To Run Type this command:
                        java packageb.ClassB
                    
                  In Java you don’t pass the extension when running a program.
                  <-> Class Paths and JARs
                        You can also specify the location of the other files explicitly using a class path. 
                        - This technique is useful when the class files are located elsewhere or in special JAR files. A JAR
                            file is like a zip file of mainly Java class files. 
                        - On Windows, you type the following:
                                java -cp ".;C:\temp\someOtherLocation;c:\temp\myJar.jar" myPackage.MyClass
                        - On Mac OS/Linux, you type this:
                                java -cp ".:/tmp/someOtherLocation:/tmp/myJar.jar" myPackage.MyClass
                        - The dot indicates you want to include the current directory in the class path. 
                        The rest of the command says to look for loose class files (or packages) in someOtherLocation and
                            within myJar.jar. 
                        - Windows uses semicolons to separate parts of the class path; other operating systems use colons.
                        Finally, you can use a wildcard (*) to match all the JARs in a directory. 
                        Ex.)
                            java -cp "C:\temp\directoryWithJars\*" myPackage.MyClass
                        This command will add all the JARs to the class path that are in directoryWithJars. 
                        It won’t include any JARs in the class path that are in a subdirectory of directoryWithJars.
        Code Formatting on the Exam::
            ->-> Not all questions will include the imports 
                 if the exam isn’t asking about imports in the question, it will often omit the imports to save space. 
                 You’ll see examples with line numbers that don’t begin with 1 in this case
                 This means when you do see the line number 1 or no line numbers at all, 
                        you have to make sure imports aren’t missing. 
    Creating Objects ::
         ->-> an object is an instance of a class
        Constructors ::
            ->-> to create an instance of a class, you just have to write new before it 
                ex.) Random r = new Random(); 
                     [type] [reference] = new [constructor]; 
            ->-> the name of the constructor matches the name of the class
            ->-> there’s no return type
            ->-> purpose is to initialize fields
            ->-> you can either initialize the field in the constructor 
                                or in the line it is created on
        Reading and Writing Object Fields ::
            ->-> you can read and write instance variables directly from the caller ( the main() method)
                 ex.)    public class Swan {
                          int numberEggs;// instance variable
                          public static void main(String[] args) {
                             Swan mother = new Swan();
                             mother.numberEggs = 1; // set variable
                             System.out.println(mother.numberEggs); // read variable
                          }
                        }
            ->-> Reading == accessing/getting the variable  
            ->-> Writing == setting the variable
            ->-> Ex of Reading and Writing ) 
                           public class Name {
                                String first = "Theodore";
                                String last = "Moose";
                                String full = first + last;
                           }
                        Lines 2 and 3 both write to fields. 
                        Line 4 does both. 
                        - It reads the fields first and last. 
                        - It then writes the field full.
        Instance Initializer Blocks ::
            ->-> the code betweeen braces {} is called a code block
            ->-> code blocks OUTSIDE of a method are called instance initializers 
        Order of Initialization ::
            ->-> Fields and instance initializer blocks are run in the order in which they appear in the file
            ->-> The constructor runs after all fields and instance initializer blocks have run
    Distinguishing Between Object References and Primitives ::
        Primitive Types ::
            ->-> the eight built-in data types
            ->-> Keyword            Type                Example 
                 boolean        true or false            true
                 byte        8-bit integral value        123
                 short       16-bit integral value       123
                 int         32-bit integral value       123
                 long        64-bit integral value       123
                 float   32-bit floating-point value   123.45f
                 double  64-bit floating-point value   123.456
                 char       16-bit Unicode value         'a'
            ->-> A byte can hold -127 - 128
            ->-> An int can hold 2^32 - 1 to 2^32
            ->-> numbers are called literals by which Java assumes is defined as an int
                    - when the number listed is bigger than an int, you need to add an L so Java knows it is a long
                    Ex.) long max = 3123456789L; 
            ->-> another specification is by changing the base ::
                    Base                    Prefix         Example
                   Octal (0-7)              0              017 // 15 in base 10 (decimal)
                  Hexadecimal(0-9)(A-F)     0x or 0X       0xA2 //162 in decimal
                   Binary(0-1)              0b or 0B       0b0110 // 6 in decimal
            ->-> you can use underscores _ between numbers NOT at the beginning, end, or by a period, of a number
                    ex.) double notAtStart = _1000.00; // DOES NOT COMPILE
                         double notAtEnd = 1000.00_; // DOES NOT COMPILE
                         double notByDecimal = 1000_.00; // DOES NOT COMPILE
                         double annoyingButLegal = 1_00_0.0_0; // COMPILES
        Reference Types ::
            ->-> A reference type refers to an object (an instance of a class)
            ->-> references do not hold the value of the object they refer to
            ->-> a reference “points” to an object by storing the memory address where the object is located,
                                                 a concept referred to as a pointer
            ->-> Reference Assignment ::
                 - A reference can be assigned to another object of the same type
                 - A reference can be assigned to a new object using the new keyword
        Key Differences ::
          ->-> References
             - can be assigned null          
             - can be used to call methods when they do NOT point to null
             - begins with uppercase
          ->-> Primitives
             - gives compiler error when attempted to assign null
             - do not have methods declared on them
             - lowercase type names
    Declaring and Initializing Variables ::
        Declaring and Initializing Variables ::
            ->-> A variable is a name for a piece of memory that stores data
            ->-> Declaring a variable involves setting a type to a reference without giving it data to be stored
                 ex.) String zooName; 
                      int seven; 
            ->-> Initializing a variable involves assigning that reference to the correct data type associated with it
                 ex.) zooName = "The Best Zoo"; 
                      int seven = 7; 
            ->-> Initialization and Declaration can happen on the same line 
                 ex.) String cat = "cat"; 
        Declaring Multiple Variables ::
            ->-> You can declare many variables in the same declaration as long as they are all of the same type
                 ex.) String s1, s2; 
            ->-> You can also initialize any or all of those values inline
                 ex.) String s3 = "this", s4 = "works"; 
            ->-> the comma is a sort of declaration snippet 
                 ex.) so String s1, s2; would be String s1; String s2; 
            ->-> You CANNOT declar nor initialize multiple variables of DIFFERENT types 
                 ex.) int num, String value; // DOES NOT COMPILE
            ->-> You CANNOT repeat a type declaration inline 
                 ex.) double d1, double d2; 
                      This is similar to declaring variables of different types 
                      double d1,d2;
                      This would work
        Identifiers ::
            ->-> legal reference names :: 
                 - The name must begin with a letter or the symbol $ or _. 
                 - Subsequent characters may also be numbers. 
                 - You cannot use the same name as a Java reserved word.
                    -- a reserved word is a keyword that Java has reserved so that you are not allowed to use it.
            ->-> reserved words :: 
                 abstract   assert      boolean         break           byte
                 case       catch       char            class           const*
                 continue   default     do              double          else
                 enum       extends     false           final           finally
                 float      for         goto*           if              implements
                 import     instanceof  int             interface       long
                 native     new         null            package         private
                 protected  public      return          short           static
                 strictfp   super       switch          synchronized    this
                 throw      throws      transient       true            try
                 void       volatile    while
            ->-> Examples of Legal and notLegal identifiers 
                 Legal Identifiers
                    - okidentifier
                    - $OK2Identifier
                    - _alsoOK1d3ntifi3r
                    - __SStillOkbutKnotsonice$
                 notLegal Identifiers 
                    - 3DPointClass // identifiers cannot begin with a number
                    - hollywood@vine // @ is not a letter, digit, $ or _
                    - *$coffee // * is not a letter, digit, $ or _
                    - public // public is a reserved word 
            ->-> In CamelCase, each word begins with an uppercase letter
            ->-> Most Java developers naming conventions ::
                    - Method and variables names begin with a lowercase letter followed by CamelCase
                    - Class names begin with an uppercase letter followed by CamelCase. 
                        -- Don’t start any identifiers with $, The compiler uses this symbol for some files
    Understanding Default Initialization of Variables ::
            ->-> Before you can use a variable, it needs a value
        Local Variables ::
            ->-> A local variable is a variable defi ned within a method
            ->-> Local variables must be initialized before use // these are NOT automatically initialized
            ->-> They do not have a default value and contain garbage data until initialized
            ->-> The compiler will not let you read an uninitialized value
            ->-> You CANNOT use variables outside of their initialized scope,
                    ex.) public void findAnswer(boolean check) {
                            int answer;
                            int onlyOneBranch; //Declared 
                            if (check) {
                                onlyOneBranch = 1; // Initialized inside of the if statement's scope
                                answer = 1;
                            } else {
                                answer = 2; 
                            }
                            System.out.println(answer);
                            System.out.println(onlyOneBranch); // DOES NOT COMPILE 
                             // because it cannot be used outside of its initialized scope
                         }
        Instance and Class Variables ::
            ->-> Variables that are not local variables are known as instance variables or class variables
            ->-> Instance variables are also called fields
            ->-> Class variables are shared across multiple objects, static and has scope for the entire class
            ->-> You can tell a variable is a class variable because it has the keyword static before it
            ->-> Instance and class variables do not require you to initialize them
            ->-> Default Initialization Values by Type ::
                 Variable Type                  Default Initialization Value
                 boolean                        false 
                 byte, short, int, long         0 (in the type's bit-length)
                 float, double                  0.0 ( in the type's bit-length)
                 char                           '\u0000' (NUL)
                 All object references          null 
    Understanding Variable Scope ::
        ->-> Local variables can never have a scope larger than the method they are defi ned in, only a smaller scope
             ex.)  public void eatIfHungry(boolean hungry) {
                    if(hungry) {
                        int bitesOfCheese = 1;
                    }   // bitesOfCheese goes out of scope here
                    System.out.println(bitesOfCheese); // DOES NOT COMPILE
                   }
                - hungry has a scope of the entire method
                - bitesOfCheese has a smaller scope, 
                    it is only available for use in the if statement because it is declared inside of it
        ->-> Every set of braces {} means you have entered a new block of code 
        ->-> The rule for class (static) variables is even easier:
             - they go into scope when declared like the other variables types
               -- they stay in scope for the entire life of the program
        ->-> Scope of the different variable types::
             - Local variables—in scope from declaration to end of block
             - Instance variables—in scope from declaration until object garbage collected
             - Class variables—in scope from declaration until program ends
    Ordering Elements in a Class ::
        ->-> Elements of a Class :: 
             Element                Example                Required?   Where does it go?
             Package declaration    package abc;           No          First line in the file
             Import statements      import java.util.*;    No          Immediately after the package
             Class declaration      public class C         Yes         Immediately after the import 
             Field declarations     int value;             No          Anywhere inside a class 
             Method declarations    void method()          No          Anywhere inside a class
        ->-> THINK: PIC -> package, import, class (in that order)
        ->-> Multiple classes can be defined in the same file but only one can be public 
             - the public class's name must also match the file's name 
             - there does NOT have to be any public classes at all 
    Destroying Objects ::
            ->-> All Java objects are stored in your program memory’s heap
            ->-> The heap, aka the free store, represents a large pool of unused memory allocated to your Java application
            ->-> If your program keeps instantiating objects and leaving them on the heap, eventually it will run out of memory
        Garbage Collection ::
            ->-> Garbage collection refers to the process of automatically freeing memory on the heap 
                            by deleting objects that are no longer reachable in your program
            ->-> You do need to know that System.gc() is not guaranteed to run 
                    but if it is added into the code, it may or may not run 
            ->-> you should be able to recognize when objects become eligible for garbage collection
            ->-> System.gc() suggests that Java should kick off a garbage collection run of which java can ignore
            ->-> An object becomes unreachable when ::
                 - The object no longer has any references pointing to it
                 - All references to the object have gone out of scope
            ->-> Objects vs References ::
                 Objects 
                    - An object sits on the heap and does not have a name
                    - no way to access an object except through a reference
                    - Objects come in all different shapes and sizes and consume varying amounts of memory
                    - An object cannot be assigned to another object, nor can an object be passed to a method or returned from a method. 
                    - It is the object that gets garbage collected, not its reference 
                 References 
                    - The reference is a variable that has a name and can be used to access the contents of an object
                    - A reference can be assigned to another reference, passed to a method, or returned from a method
                    - All references are the same size, no matter what their type is
        finalize() ::
            ->-> This method gets called if the garbage collector tries to collect the object
            ->-> If the garbage collector doesn’t run, the method doesn’t get called
            ->-> If the garbage collector fails to collect the object and tries to run it again later, 
                                            the method doesn’t get called a second time
            ->-> could run zero or one time
            ->-> garbage collection will not be called on static methods until they are null/ aren't pointing to any data anymore    
    Benefits of Java ::
        ->-> Java is an object-oriented language, meaning code is defined in classes which can then be instantiated as objects
        ->-> Java supports access modifiers to protect data from uninteded access and modification
        ->-> Java code gets compiled once which can then be run anywhere (if asked, the same class files run everywhere)
        ->-> Java prevents memory leaks as it manages memory on its own and does garbage collection automatically 
        ->-> Java runs inside the JVM making it difficult to corrupt/ do bad things to the computer it is running on 
    Exam Essentials ::
        ->-> Be able to write code using a main() method 
        ->-> Understand the effect of using packages and imports 
        ->-> Be able to recognize a constructor 
        ->-> Be able to identify legal and notLegal declarations and initialization
        ->-> Be able to determine where variables go into and out of scope 
        ->-> Be able to recognize misplaced statements in a class 
        ->-> Know how to identify when an object is eligible for garbage collection 
Chapter 2 [Operators and Statements]::
    PDF Page: 97
    Understanding Java Operators ::
        ->-> a java operator is a special symbol that can be applied to a set of 
                        variables, values, or literals that returns a result
        ->-> Order of Operator Precedence 
            Operator                            Symbols and examples 
            Post-unary operators                expression++, expression--
            Pre-unary operators                 ++expression, --expression
            Other unary operators               + , - , !
            Multiplication/Division/Modulus     * , / , %
            Addition/Subtraction                +, -
            Shift operators                     <<, >>, >>>
            Relational operators                < , > , <= , >=, instanceof
            Equal to/ not equal to              ==, != 
            Logical operators                   &, ^, | 
            Short-circuit logical operators     &&, || 
            Ternary operators                   boolean expression ? expression1 : expression2
            Assignment operators                =, +=, -=, *=, /=, %=, &=, ^=, !=, <<=, >>=, >>>= 
    Working with Binary Arithmetic Operators ::
        Arithmetic Operators ::
            ->-> normal operators like addition, subtraction, multiplication, division, modulus 
                                            as well as unary operators such as ++ and -- 
            ->-> multiplicative operators have a higher order of precedence than addative operators 
            ->-> anything in parenthesis happens first ALWAYS 
            ->-> addition operators + and += can be applied to String values, resulting in String concatenation
            ->-> modulus, %, gets you the remainder of what is divided, modulus is not limited to positive numbers 
        Numeric Promotion ::
            ->->  Numeric Promotion Rules 
                - If two values have different data types, Java will automatically promote one of the values to the larger of the two data types
                - If one of the values is integral and the other is floating-point (basically if one is a whole number and one is a decimal number) 
                        Java will automatically promote the integral value to the floating-point value's data type
                - Smaller data types, aka byte, short, and char, are first promoted to int any time they're used with a Java binary arithetic operator
                        even if neither of the operands is int 
                - After all promotion has occurred and the operands have the same data type, the resulting value will have the same data type as its promoted operands 
                    (essentially once everything has bee promoted, whatever you get as a result is the highest promoted value )
    Working with Unary Operators :: 
         ->-> a unary operator is one that requires EXACTLY one operand, or variable, to function 
         ->-> Java Unary Operators 
            Unary Operator       Description 
            +                    Indicates a number is positive, although numbers are assumed to be positive in 
                                    Java unless accompanied by a negative unary operator
            -                    Indicates a literal number is negative or negates an expression 
            ++                   Increments a value by 1 
            --                   Decrements a value by 1
            !                    Inverts a Boolean's logical value 
        Logical Complement and Negation Operators ::
            ->-> the Logical Complement Operator, !, flips the value of a boolean expression
            ->-> the negation operator, -, reverses the sign of numeric expression
            ->-> you CANNOT apply negation operators on booleans nor logical complement operator for numerical expressions 
        Increment and Decrement Operators ::
            ->-> ++ and -- have a higher precedence than binary operators, meaning they often get applied first
            ->-> pre-increment/decrement is when the operator is applied to BEFORE the associated operand 
                    ex.) int counter = 0; 
                         System.out.println(counter); // Outputs 0
                         System.out.println(++counter); // Outputs 1
                         System.out.println(counter); // Outputs 1
            ->-> post-increment/decrement is when the operator is applied to AFTER the associated operand
                    ex.) counter = 1; 
                         System.out.println(counter); // Outputs 1
                         System.out.println(counter--); // Outputs 1
                         System.out.println(counter); // Outputs 0
            ->-> Example of them in a numerical expression 
                    int x = 3;
                    int y = ++x * 5 / x-- + --x;
                    System.out.println("x is " + x);
                    System.out.println("y is " + y);

                   //left most ++x is evaluated// int y = 4 * 5 / x-- + --x; // x assigned value of 4
                   //then the x-- is evaluated//  int y = 4 * 5 / 4 + --x; // x assigned value of 3
                   //then the --x is evaluated//  int y = 4 * 5 / 4 + 2; // x assigned value of 2
                   
                   Then you evaluate the expression as a whole so 
                   x is 2
                   y is 7
    Using Additional Binary Operators ::
        Assignment Operators ::
            ->-> An assignment operator is a binary operator that modifies, or assigns, the variable on the left-hand side of the operator 
                                        with the result of the value on the right-hand side of the equation
            ->-> You CANNOT assign/ store larger data types inside of smaller data types 
                 int x = 1.0 // does NOT compile 
                 1.0 cannot be assigned to int x 
                 long t = 192301398193810323; // does NOT compile 
                 Java interprets literals as ints unless the L was added to the end of the number, allowing java to know the type of data.
        Casting Primitive Values :: 
            ->-> When going from a larger numerical data type to a smaller numerical data type, 
                    or converting from a floating-point number to an integral value, CASTING is required
                    (in the sense of if you have int x = 1.0, to make the code compile you would do int x = (int)1.0 // giving 1)
            ->-> Overflow and Underflow ::
                    ->-> Overflow :: when a value attempting to be stored is larger than the data type it is trying to store in 
                            ex.) short x = (short)1921222, then an overflow occurs, 
                            essentially wrapping around to the next lowest value then couting up from there 
                    ->-> Underflow :: same thing as overflow but if you have a number too low to fit the data type
            ->-> EXAMPLE OF TRICKY STUFF
                 short x = 10;
                 short y = 3;
                 short z = x * y; // DOES NOT COMPILE
                 - trying to assign x * y to z does not compile because Java, when doing arithmetic, promotes smaller values to an int
                 - you would have to cast the x * y like this -> short z = (short)(x * y) 
        Compound Assignment Operators ::
            ->-> the compound operator will automatically cast the resulting value to the data type of the value on the left-hand side of the compound operator 
                 ex.) long x = 10; 
                      int y = 5; 
                      y = y * x; // does NOT compile 
                      BUT 
                      long x = 10; 
                      int y = 5; 
                      y *= x; // DOES compile, compound assingment operator, *=,
            ->-> SOMETHING WEIRD 
                 long x = 5; 
                 long y = (x=3) // assigns x to 3 then y to x
                 System.out.println(x) // prints 3
                 System.out.println(y); // prints 3 as well
        Relational Operators ::
            ->-> Relational Operators 
                 Operator                Definition
                 <                       Strictly less than 
                 <=                      Less than or equal to 
                 >                       Strictly greater than 
                 >=                      Greater than or equal to 
                 a instanceof b          if the reference that a points to is an instanceof a class, subclass, or class 
                                            that implements a particular interface, as named in b
        Logical Operators ::
            ->-> Logical operators: &, |, and ^
            ->-> They can be applied to both numeric and boolean data types 
            ->-> When they are applied to numeric types they are referred to as bitwise
            ->-> they are referred to as bitwise because they compare the bits 
            ->-> Conditional Operators :: 
                - Conditional Operators are also referred to as short-circuit operators 
                - Similar to Logical operators in how they look they are AND, &&; OR, ||; XOR, ^; 
                - The right hand of the expression may never be evaluated IF 
                    the final result can be determined by the left-hand side of the expression 
                - Commonly used to check for null objects 
            ->-> TIP TO REMEMBER THE OPERATORS FUNCTION 
                    - AND, &, && - is only true if BOTH operands are true
                    - Inclusive OR , |, ||, is only false if BOTH operands are false
                    - Exclusive OR, ^, is only true if the operands are DIFFERENT 
        Equality Operators ::
            ->-> The equality operators are used in one of three scenarios:
                - Comparing two numeric primitive types. If the numeric values are of different data types, 
                            the values are automatically promoted. ex) 5 == 5.00 returns true, left is promoted to a double
                - Comparing two boolean values 
                - Comparing two objects, including null and String values (NOT THEIR CONTENTS)
            ->-> WEIRD THING::
                ex.) boolean y = false; 
                     boolean x = (y = true); 
                     System.out.println(x); // true; 
    Understanding Java Statments ::
        The if-then Statement ::
            ->-> syntax of an if-then statement::
                if(booleanExpression){      
                    // Branch if true       
                }
                - curly braces required for block of multiple statements, optional for single statement
        The if-then-else Statement ::
            ->-> structure of if-then-else statement::
                if(booleanExpression){
                    //branch if true
                }else{
                    //branch if false
                }
                -Curly braces required for block of multiple statements, optional for single statement
        Ternary Operator::
            ->-> ? : ,aka the ternary operator, which takes three operands 
            ->-> looks like -- booleanExpression ? expression1 : expression2
            ->-> does expression1 if true, does expression2 if false
            ->-> helpful to put parenthesis around expression but NOT required
            ->-> Example of unable to compile code:: int animal = (y < 91) ? 9 : "Horse"; 
        The switch Statement ::
            ->-> a switch statement is a complex decision-making structure in which a single value is evaluated 
                    and flow is redirected to teh first matching branch, known as a case statement
            ->-> If there are no case statements found that matches the value, an OPTIONAL default statement will be called
                    - if there is no default statement, the entire switch statement is skipped
            ->-> Switch statements can allow the matching of enums, String values, and
                    primitive numeric wrapper classes such as Byte Short Character or Integer
            ->-> Structure of a switch statement::
                  switch(variableToTest){
                    case constantExpression1:
                        //branch for case;
                        break; 
                    case constantExpression2:
                        //branch for case;
                        break; 
                    default:
                        //branch for default
                  }
                  - NOTE: the default statement can be anywhere and will continue to the next case, running the branch from it until a break; statement is reached. 
                  - Curly braces required
                  - switch statement may contain 0 or more case branches
                  - break statements are optional
            ->-> data types supported :
                - int and Integer
                - byte and Byte
                - short and Short
                - char and Character 
                - String 
                - enum values 
            ->-> Compile-time Constant Values:: 
                 the vaules in each case statement must be compile-time constant values of the same data type as the switch value
                 meaning you can only use literals, enum constants, or funal constant variables of the same data type
            ->-> final constant means the variable is marked with the final modifier 
                 and initialized with a literal value in the same expression in which it is declared 
            ->-> if a value is attempted to be the constantExpression which comes after the case, is final, 
                    but is passed into a function, then the switch statement cannot use it
        The while Statement ::
            ->-> a loop structure/ repetition control structure, 
                which executes a statement of code multiple times in succession
            ->-> The structure of a while statement : 
                 while(booleanExpression){
                    //body
                 }
                 - Curly braces are required for block of multiple statements, OPTIONAL for single statement 
            ->-> The boolean expression is evaluaed before each iteration of the loop 
                        and exits if the evaluation returns false 
        The do-while Statement ::
            ->-> guarantees that the statement or block will be executed at least once
            ->-> The structure of a do-while statement: 
                 do {  
                    //body
                 }while(booleanExpression); 
                 - semi colon required
                 - Curly braces required for block of multiple statements, OPTIONAL for single statement 
        The for Statement ::
            ->-> there are two types: the normal for loop and something called a for-each loop or enhanced for loop
            ->-> structure of a basic for statement:
                for(initialization; booleanExpression; updateStatement){
                    //Body
                }
                -Curly Braces required for block of multiple statements, OPTIONAL for single statement
                1.) Initialization statement executes 
                2.) If booleanExpression is true, continue, else, exit loop
                3.) Body executes 
                4.) Execute updateStatements
                5.) Return to step 2 
            ->-> for loops can look like this -> for( ; ; ){ //body } and compile just fine 
                    the only problem is that it runs an infinite loop 
            ->-> the components of the for loop are each optional in their own right, but suggested and are commonly seen used 
            ->-> the semicolons are required (two ; ; )
                    for( ; ) and for( ) will not compile 
            ->-> you can have multiple initialization statements and multiple update statements but only ONE boolean statement 
                        (it can look like x > 10 && y < 10 or just  x < 10)
                - for(long y = 0, z = 4; x < 5 && y < 10; x++, y++) {
                        System.out.print(y + " "); 
                  }
                  System.out.print(x); 
            ->-> You CANNOT redeclare a variable in the initialization block 
                - int x = 0; 
                  for(long y = 0, x = 4; x < 5 && y < 10; x++, y++){
                    System.out.print(x + " "); 
                  }
                  -- this is will not compile because once you have initialized a variable to a specific type, 
                        you CANNOT assign it to a different type which is what is happening
                - this part next is legal:
                    int x = 0; 
                    long y = 10; 
                    for(y = 0, x = 4; x < 5 && y < 10; x++, y++) {
                        System.out.print(x + " "); 
                    }
                    THIS COMPILES
            ->-> You cannot use incompatible data types in the initialization block 
                - for(long y = 0, int x = 4; x < 5 && y < 10; x++, y++) {
                    System.out.print(x + " " ); 
                }
                this will NOT compile 
            ->-> You CANNOT use loop variables (those from the initialization block) outside of the for loop 
                - for(long y = 0, x = 4; x < 5 && y < 10; x++, y++){
                    System.out.print( y + " "); 
                }
                System.out.print(x); //will NOT compile
                - this is because of scope 
                BUT 
                - long x = 0; 
                for(x = 10; x > 3; x--){
                    System.out.println(x); 
                }
                System.out.println(x + " " ); //this WILL compile
        The for-each statement: 
            ->-> The structure of a for-each loop: 
                for(datatype instance : collection) {
                    //Body
                }
                - the colon is required 
                - Curly braces required for block of multiple statements, OPTIONAL for single statement
                - the collection has to be iterable 
            ->-> the right hand side of the for each loop must be an array or an object whose class implements java.lang.Iterable 
            ->-> the left hand side of the for each loop must inclde a declaration for an instance of a variable, 
                  whose type matches the type of a member of the array or collection in the right hand side of the statement
            ->-> on each iteration of the loop, the named variable on the left-hand side of the statement is 
                    assigned a new value from the array or collection on the right-hand side of the statement 
            ->-> The data type passed in has to match the data type of the array/ iterable object 
                - ex.) String[] names = new String[3]; 
                       for(int name : names) {
                            System.out.println(name + " " ); 
                       }
                       - This will NOT compile because the int name does not match the type of names
    Understanding Advanced Flow Control ::
        Nested Loops ::
            ->-> loops can contain other loops 
            ->-> when the outer loops runs once, the inner loop runs as many times as it goes so 
                 ex.) 
                    for(int i = 0; i < 2; i++){
                        for(int j = 0; j < 5; j++){
                            //body 
                        }
                    }
                    - the inner loop with j runs 5 times for every time the outer loop runs 
                    - if there was a counter for some sort of total within the inner loop the it wuld be 
                            5 * 2 because the outer loop runs 2 times                             
        Adding Optional Labels ::
            ->-> All previous java statements can have optional labels 
            ->-> Labels are an optional pointer to the head of a statement that 
                    allows the application flow to jump to it or break from it. 
            ->-> It is a single word that is proceeded by a colon (:)
                -ex.) OUTER_LOOP: for(int i = 9; i > 0; i--){
                                     for(int j = 0; j < 10; j++){
                                        break OUTER_LOOP; 
                                     }
                                  }
                - the outer loop would be broken
            ->-> with labels, you can specify what is continued (continue) , or broken (break)
            ->-> you can also add labels to control and block structures but it isn't good coding practice to do so
        The break Statement ::
            ->-> a break statement transfers the flow of control out to the enclosing statement 
            ->-> Structure of a break statement : 
                 optionalLabel: while(booleanExpression) {
                    //body
                    
                    //somewhere in the loop

                    break optionalLabel; 
                 }
                 - optionalLabel is obviously optional
                 - it doesn't explicitly have to be a while loop, any loop works 
                 - you can either break; or break optionalLabel; 
            ->-> Without an optional label parameter, the break statement will terminate the nearest inner loop it is currently in 
            ->-> With the optionalLabel, if it is the for the outer loop, break OUTER_LOOP would break out of the entire loop structure
        The continue Statement ::
            ->-> The structure of a continue statement: 
                 optionalLabel: while(booleanExpression) {
                    // Body 

                    // Somewhere in the loop 
                    continue optionalLabel; 
                 }
                 - same deal as the break statement except instead of breaking outside of the loop 
                        it continues the loop from right after whatever iteration it was on 
            ->-> A continue statement transfers control to the boolean expression 
                            that determines if the loop should continue
                    - basically it ends the current iteration of the loop
            ->-> It is applied to the nearest inner loop under execution, unless there is an optionalLabel 
            ->-> EXAMPLE: 
                public class SwitchSample { 
                    public static void main(String[] args) {
                        FIRST_CHAR_LOOP: for(int a = 1; a <= 4; a++){
                            for( char x = 'a'; x < = 'c'; x++){
                                if(a == 2 || x == 'b')
                                    continue FIRST_CHAR_LOOP; 
                                System.out.print(" " + a + x); 
                            }
                        }
                    }
                }
                - the loop will return control to the parent loop any time the first value is 2 or the second value is backslashes             
        ->-> Advanced Flow Control Usage::
            Statement           Allows optional labels         Allows break statement           Allows continue statement
            if                  Yes*                           No                               No
            while               Yes                            Yes                              Yes
            do while            Yes                            Yes                              Yes 
            for                 Yes                            Yes                              Yes 
            switch              Yes                            Yes                              No 
            -* labesl are allowed for any block statement, including those that are preceded with an if-then statement 
    Exam Essentials ::
        ->-> Be able to write code that uses Java Operators 
        ->-> Understand Java operator precedence 
        ->-> Be able to write code that uses parenthesis to override operator precendence 
        ->-> Understand if and switch decision control statements 
        ->-> Understand loop statements
        ->-> Understand how break and continue can change the flow control 
    Excess Notes :: 
        ->-> you can assign booleans inside the if parenthesis if(b = true) is completely fine(apparently) 
Chapter 3 [Core Java APIs]::
    PDF Page: 147
    Creating and Manipulating Strings ::
        ->-> a String is a sequence of characters
        Concatenation ::
            ->-> Rules for concatentation::
                1. If both operands are numeric, + means numeric addition
                2. If either operand is a String, + means concatenation 
                3. The expression is evaluated left to right 
            ->-> REMEMBER : += for strings and every type looks like this, 
                        s += "1" is the same as s = s + "1"; 
        Immutability ::
            ->-> When a String object is created, it is not allowed to change 
                 - it CANNOT be made larger or smaller nor can you change one of the characters inside 
            ->-> Mutable is another word for changeable, Immutable is the opposite -- an object that CANNOT be changed once it is created. 
            ->-> Strings are Immutable 
            ->-> for class immutability, you need to make the class final so, final class , would be properl
            ->-> .concat(String) is another way to concatonate a string to another string. 
            ->-> EXAMPLE : 
                String s1 = "1"; 
                String s2 = s1.concat("2"); 
                s2.concat("3"); 
                System.out.println(s2); // prints 12
        The String Pool ::
            ->-> The string pool contains literal values that appear in your program
            ->-> String name = "Fluffy" vs String name = new String("Fluffy") , the first one is a string literal, 
                    the second is an object that is able to be garbage collected and does NOT go into the String pool 
            ->-> A string is a sequence of characters
            ->-> Java starts at 0 when indexing so "Hello" the "H" is at index 0
        Important String Methods ::
            ->-> length() - returns the number of characters in the String // returns an int
                (this one starts counting at 1 so "Hello".length() would return 5)
            ->-> charAt(index x) - returns the charAt the specified index // returns a char
                    so ("Hello".charAt(1) would return "e")
                    - trying to get the charAt an index that is out of the Bounds of the String you're searching through will throw an exception
            ->-> indexOf() - looks at the characters in the string and finds the first index that matches the desired value //returns an int
                 - Method Signatures of indexOf() :
                    - int indexOf(char ch) - passes in a char for the argument 
                    - int indexOf(char ch, index fromIndex) - passes in a char for the argument and the index you want to start searching from 
                    - int indexOf(String str) - passes in a String for the argument to find a specific index of that ENTIRE String
                    - int indexOf(String str, index fromIndex) - passes in a String for the argument and the index you want to start searching from 
            ->-> substring() - looks for a substring of characters in a string and returns a part of the string //returns a string
                                the first parameter is the index to start from and there can be a second optional parameter that 
                                stops at that index (it will not include the character at that index)
                                this means that the second parameter is allowed to be 1 past the index of the last character/ 1 more than where you are searching to 
                                - Method Signatures of substring() : 
                                    - String substring(int beginIndex) - goes from the beginning index all the way until the end of the string
                                    - String substring(int beginIndex, int endIndex) - goes from the beginning index up until the endIndex
                                                                                         (does NOT include the end index) 
                                - having a beginIndex that is greater than the endIndex will throw an exception 
                                - having a beginIndex that is equal to your endIndex will return an empty string -> ""
                                - having an endIndex that is over the length of your string will throw an exception ("Hello".substring(0,6) will throw an exception)
            ->-> toLowerCase() and toUpperCase() - converts the string to either all lowercase or all uppercase depending on which method is used // returns a string
                    - Do NOT forget that strings are immutable so the original string stays the same 
            ->-> equals() and equalsIgnoreCase() - check whether two String objects contain EXCATLY the same characters in the same order //returns a boolean
                                                    equalsIgnoreCase() does NOT care about lowercase vs uppercase as long as what is there matches 
                                                    ex.) "HelLo".equals("Hello") would return false
                                                         "HeLlO".equalsIgnoreCase("hElLo") would return true 
            ->-> startsWith() and endsWith() - checks whether or not the provided value matches either the beginning or end of the string 
                                                                        (depends on the method used)   returns a boolean 
            ->-> contains() - looks for whether the string contains the provided value // returns a boolean 
                              - does NOT ignore case which mean "abc".contains("B") would return false
            ->-> replace() - does a simple search and replace on the string, returns a string 
                        - Method Signature of replace() : 
                            String replace(char oldChar, char newChar)
                            String replace(CharSequence oldChar, CharSequence newChar) -- CharSequence can be a string like "hello" 
            ->-> trim() - removes the whitespace from the beginning and end of a string   
                            (whitespace consists of spaces along with \t and \n characters as well as \r (carriage returns) ) 
        Method Chaining ::
            ->-> you can chain methods together
            ->-> EXAMPLE : String result = "AniMal      ".trim().toLowerCase().replace('a','A') will return AnimAl
            ->-> do NOT forget !!! Strings are mutable 
                    ex.) String a = "abc"; 
                         String b = a.toUpperCase(); 
                         System.out.println(a); // this will print abc still 
    Using the StringBuilder Class ::
        ->-> StringBuilders are mutable
        Mutability and Chaining ::
            ->-> Chaining when it comes to StringBuilder objects changes the state of the object and returns the reference to itself
                        ( essentially the reference of the StringBuilder object changes when used ) 
                        ex.) StringBuilder test = new StringBuilder("abc"); 
                             StringBuilder t1 = test.append("def");
                             System.out.println(test); // prints abcdef
                             System.out.println(t1); // prints abcdef
            ->-> think of StringBuilder object like this :
                    StringBuilder sb = new Stringbuilder("object"); 
                    - whenver you use a method of the StringBuilder class, it returns the StringBuilder reference 
                        so sb.append("Hello") really looks like sb += "object" in String terms            
        Creating a StringBuilder ::
            ->-> There are 3 ways to construct a StringBuilder object: 
                    - StringBuilder sb1 = new StringBuilder(); // creates an empty sequence of characters of which sb1 points to
                    - StringBuilder sb2 = new StringBuilder("Hello"); // creates a StringBuilder containing a specific value, assigns to sb2 
                    - StringBuilder sb3 = new StringBuilder(10); // reserves that many 'slots' for some characters (like a size)
            ->-> Size vs Capacity ::
                 - Size is the number of characters currently in the sequence 
                    ex.) a StringBuilder that = "hello" currently has a size of 5
                 - capacity is the number of characters the sequence can hold
                    ex.) a StringBuilder(10) could hold 10 characters but has a current SIZE of 0; 
                 - StringBuilder default capacity = 16; 
                 - Adding in more than the capacity makes it to where it will have a capacity one more than its size 
        Important StringBuilder Methods ::
                                         ***IMPORTANT NOTE*** 
                        the methods here do NOT do what append does (check example) 
            (basically they do NOT return the original StringBuilder + whatever the substring and such is)
            ->-> charAt() - works the same as the String charAt();
            ->-> indexOf() - works the same as the String indexOf();
            ->-> length() - works the same as the String length(); 
            ->-> substring() - works the same as the String substring();
            ->-> append() - adds the parameter to the StringBuilder and returns a reference to the current StringBuilder
                    Method signature : StringBuilder append(String str) // NOTE* there are more than 10 different signatures for append()
                                         // Just REMEMBER that StringBuilder treats whatever is in that parameter as a sequence of characters 
            ->-> insert() - adds characters to the StringBuilder at a specific index and returns a reference to the current StringBuilder
                    Method Signature : StringBuilder insert(int offset, String str)
                 - you CAN use one above the size of your StringBuilder as the inserting index 
                 ex.) StringBuilder sb = new StringBuilder("animals")
                        sb.insert(7, "-")   // sb is now  animals-  
                        sb.insert(0, "-")   // sb is now -animals- 
                        sb.insert(4, "-")   // sb is now -ani-mals- 
            ->-> delete() - removes a character from the sequence and returns a reference to the current StringBuilder 
                    Method Signature : StringBuilder delete(int start, int end); (exclusive, meaning it goes until it gets to end) 
            ->-> deleteCharAt() - removes a character from the sequence at a specific index (will ONLY remove one character)
                    Method Signature : StringBuilder deleteCharAt(int index)
            ->-> reverse() - reverses the characters in the sequence and returns a reference to the current StringBuilder 
                    Method Signature : StringBuilder reverse()
            ->-> toString() - converts a StringBuilder into a String 
                    Method Signature : String toString() 
        StrigBuilder vs. StringBuffer ::
            ->-> StringBuffer does the same thing as StringBuilder but more slowly because it is thread safe 
    Understanding Equality ::
        ->-> String Equality: 
            String x = "Hello World"; 
            String y = "Hello World"; 
            String z = "Hello World".trim(); 
            System.out.println(x == y) // true because they point to the same String literal
            System.out.println(x == z) // false because they technically are not the same String literal
                        - same deal with when creating two different new String(someString);, 
                                                they will not equal each other
        ->-> StringBuilder class does NOT have a equals() so 
                calling it on two StringBuilder would check for reference equality
    Understanding Java Arrays ::
            ->-> an array is an area of memory on the heap with space for a designated number of elements
            ->-> an array can be of any Java type
            ->-> it is an ordered list
            ->-> arrays are immutable
        Creating an Array of Primitives ::
            ->-> basic structure of an array : 
                    int[] numbers = new int[3]; 
                    - type of array 
                    - array symbol [] 
                    - new int[ size ]
            ->-> you start indexing at 0 
            ->-> when you already know the size of the array you want and its values, you can create an anonymous array
                                it is anaonymous because you don't specify the type and size
                    ex.) int[] nums = {12,22,300}; 
            ->-> All are acceptable array initializations : 
                        - int[] num; 
                        - int [] num; 
                        - int num[]; 
                        - int num []; 
            ->-> Multiple "Arrays" in Declarations : 
                - int[] ids, types; // this will create two variables of type int[] 
                - int ids[], types; // this will create one variable of type int[] and one of type int; 
        Creating an Array with Reference Variables ::
            ->-> You can call equals() because an array is an object 
            ->-> An array allocates space for a reference where the objects are stored 
            ->-> CAREFUL****
                -  String[] strings = { "stringValue" }; // creates an array of Strings 
                -  Object[] objects = strings; // creates an array of objects, has it hold the contents of the previous String array
                -  String[] againStrings = (String[]) objects; 
                    // makes a new array of Strings but uses the contents of objects which is holding ONLY strings so you HAVE to make the cast
                -  againStrings[0] = new StringBuilder(); // DOES NOT COMPILE, // This is basically trying to place a StringBuilder OBJECT 
                -  objects[0] = new StringBuilder(); // this compiles but will throw an exception at runtime because the Object[] array holds objects,
                                                     // StringBuilder is an object (it inherits from the Object class) but it isn't of Object...it is of StringBuilder
        Using an Array ::
            ->-> you can use .length after an array reference to get the length of the array
                  // .length gets the size,not capacity, meaning String b[] = new String[6]; b.length will return 6
                    ex.) int[] k = {5, 25, 100};
                         System.out.println(k.length); // outputs 3
            ->-> To access a specific item in an array, use [] and then put the index it appears inside    
                    ex.) int k[] = {12, 14, 16, 18, 20};
                         System.out.println(k[0]); // outputs 12
            ->-> Indexes start at 0, just like Strings 
            ->-> You can set specific indexes of an array to the type 
                    ex.) int[] nums = new int[10]; 
                         nums[9] = 65; 
                         nums[10] = 100; // this CANNOT compile and will be an error because 10 is an invalid index 
        Sorting ::
            ->-> you MUST import the Arrays class, 
                 import java.util.Arrays; // imports only Arrays 
                          or 
                 import java.util.*;   // imports the whole package including Arrays
            ->-> you can use Arrays.sort(someArray); to sort the array in order from least to greatest
                    or, in terms of strings, alphabetically 
                  *** KEEP IN MIND *** when sorting String[] strings = {"10",9"","100"};
                        Arrays.sort(strings) will put the array in this order // 10 100 9
                        because 1 comes before 9 on the ascii table
        Searching ::
            ->-> method used is Arrays.binarySearch(someArray, itemWantedToFind); 
            ->-> Binary search rules ::
                    Scenario                                     Result 
                    Target elements found in sorted array        Index of index of matching target in array
                    Target elements not found in sorted array    Negative value showing one smaller than the negative of index,
                                                                     where a match needs to be inserted to preserve sorted order
                    Unsorted array                               A surprise-this result isn't predictable
                 -- ex.) int[] numbers = {2,4,6,8}; 
                        System.out.println(Arrays.binarySearch(numbers, 2)); // outputs 0
                        System.out.println(Arrays.binarySearch(numbers, 4)); // outputs 1
                        System.out.println(Arrays.binarySearch(numbers, 1)); // outputs -1
                        System.out.println(Arrays.binarySearch(numbers, 3)); // outputs -2
                        System.out.println(Arrays.binarySearch(numbers, 9)); // outputs -5
        Varargs ::
            ->-> Examples of the main method:
                 public static void main(String[] args);
                 public static void main(String args[]);
                 public static void main(String... args); // this is varargs
            ->-> NOTE *** args.length and args[0] are legal and perfectly valid to used            
        Multidimensional Arrays ::
            ->-> syntax of a multidimensional array 
                 int[][] vars1;                // 2D array
                 int vars2 [][];               // 2D array
                 int[] vars3 [];               // 2D array 
                 int[] vars4 [], space [][];   // vars4 is a 2D array, space is a 3D array
                 ** remember that when the type is at the beginning of a multi-instantiation, 
                        it carries through the entire instantiation so
                        int vars4 [], space[][] creates vars4 as an array and space as a 2D array 
            ->-> Array instantiation and sizing: 
                    - you can specify the size of the multidimensional array just like a 1D array
                        ex.) String [][] rectangle = new String[3][2]; 
                    - you can also just plop in arrays within arrays of different sizes 
                        ex.) int[][] differentSize = { {1,4}, {3}, {9,8,7}};
                    - you can also just specify one piece of the array and not the other side; 
                        ex.) int [][] args = new int[4][]; 
                             args[0] = new int [5]; // this puts and array of 5 spaces at args[0]
            ->-> Using loops for multidimenstional arrays: 
                    for( int[] inner : twoD){
                        for(int num : inner){
                            System.out.print(num); 
                        }
                        System.out.println(); 
                    }
                    - what this enhanced for loop does is make a loop for each array inside of the twoD (2D) array 
                        and loops through each of those, for each num inside of inner, print num 
                 - you can also use multiple nested normal for loops to access specific indexes of the multidimensional array
    Understanding an ArrayList:: 
            ->-> To use ArrayList, it requires an import
                    import java.util.*;         // imports whole util package incuding ArrayList
                           or
                    import java.util.ArrayList; // imports just ArrayList
            ->-> ArrayLists are mutable
        Creating an ArrayList ::
            ->-> The three different ways to create an ArrayList: 
                 - ArrayList list1 = new ArrayList();      // makes an ArrayList of the default capacity
                 - ArrayList list2 = new ArrayList(100);   // makes a list with a capacity of 100
                 - ArrayList list3 = new ArrayList(list2); // makes an ArrayList that copies the contents and size of the passed in list 
            ->-> You can also specify the type that will be put into the ArrayList with generics
                 ex.) ArrayList<String> list4 = new ArrayList<String>(); 
                      ArrayList<String> list5 = new ArrayList<>(); 
            ->-> You are also allowed to store an ArrayList in a List reference variable but not vice versa 
                 ex.) List<String> list6 = new ArrayList<>(); 
                      ArrayList<String> list7 = new List<>(); // does NOT compile because interfaces cannot be instantiated
            *** NOTE *** if you do NOT specify what goes in the ArrayList with generics, anything can be place in the ArrayList
        Using an ArrayList ::
            ->-> printing a list returns the list in brackets like this 
                    ex.) ArrayList list = new ArrayList(); 
                         list.add("hawk"); 
                         list.add(Boolean.TRUE); 
                         System.out.println(list); // [hawk, true]
            ->-> add() - inserts a new value in the ArrayList at the end of the list 
                    Method signature:
                    boolean add(E element); // this always returns true
                        // It exists becaue other classes in the collections family need a return value in the signature when adding an element 
                    void add(int index, E element); - adds an element at the specified index 
                 *** if you attempt to add something that does NOT fit into the generics of the ArrayList, 
                            then the add attempt will NOT compile 
            ->-> remove() - removes the FIRST matching value in the ArrayList OR removes the element at a specified index 
                    Method signature :
                    boolean remove(Object object); // this actually returns whether a match was removed or not, removes that match if there is one 
                    E remove(int index); // removes the element at the specified index, choosing an invalid index to remove will throw an exception                   
            ->-> set() - changes one of the elements of the ArrayList without changing the size
                    Method signature : 
                    E set(int index, E newElement); // sets whatever was at the index to whatever newElement you input 
                                // do NOT forget about having valid indexes (an index that = the capacity is actually valid for ArrayLists)
                                // do NOT forget that the element has to match the type specified by the generic 
            ->-> isEmpty() - returns true if the list is empty, if it is not empty then returns false 
                    Method signature:
                    boolean isEmpty(); 
            ->-> size() - returns the size of the ArrayList, not the capacity 
                    Method signature: 
                        int size(); 
            ->-> clear() - discards all the elements within an ArrayList
                    Method signature:
                    void clear()
            ->-> contains() - checks whether a certain value is in the ArrayList, 
                                returns true if the list contains the value, false if not
                    Method signature: 
                    boolean contains(Object object)
            ->-> equals() - compares two lists to see if they contain the SAME elements in the SAME order
        Wrapper Classes ::
            ->-> the Different Wrapper classes 
                Primitive type              Wrapper class             Example of constructing 
                boolean                     Boolean                   new Boolean(true);
                byte                        Byte                      new Byte( (byte)1 );
                short                       Short                     new Short( (short)1 );
                int                         Integer                   new Integer(1);
                long                        Long                      new Long(1);
                float                       Float                     new Float(1.0); 
                double                      Double                    new Double(1.0); 
                char                        Character                 new Character('c'); 
            ->-> Converting String to primitive 
                 You can convert a String to a primitive or wrapper class 
                 Wrapper class          Converting String to primitive   Converting String ot wrapper class 
                 Boolean                Boolean.parseBoolean("true");    Boolean.valueOf("TRUE"); 
                 Byte                   Byte.parseByte("1");             Byte.valueOf("2"); 
                 Short                  Short.parseShort("1");           Short.valueOf("2");
                 Integer                Integer.parseInt("1");           Integer.valueOf("2"); 
                 Long                   Long.parseLong("1");             Long.valueOf("2"); 
                 Float                  Float.parseFloat("1");           Float.valueOf("2.2"); 
                 Double                 Double.parseDouble("1");         Double.valueOf("2.2"); 
                 Character                  NONE                               NONE     
                - the reason Character has none is because a String is made up of characters so calling charAt() does the same thing
        Autoboxing ::
            ->-> Essentially Java will convert the primitive value to the relevant wrapper class for you when appropriate 
            ->-> Trying to unbox a null will result in a NullPointerException
            ->-> CAREFUL ***
                 List<Integer> numbers = new ArrayList<>(); 
                 numbers.add(1); 
                 numbers.add(2); 
                 numbers.remove(1); 
                 System.out.print(numbers) // outputs [1]
                 - it uses the index of 1 not the Integer(1)
                 - to force the method remove() to remove the 1, 
                    you can write numbers.remove(new Integer(1)) to force a wrapper class to be used
        Converting Between array and List ::
            ->-> Process of conversion (List to Array)
                 List<String> list = new ArrayList<>(); 
                 list.add("hawk"); 
                 list.add("robin"); 
                 Object[] objectArray = list.toArray(); // converts list to an Object[] 
                 System.out.println(objectArray.length); // outputs 2
                 String[] stringArray = list.toArray(new String[0]); // converts the list to a String[] 
                 System.out.println(stringArray.length);        // outputs 2
            ->-> Process of conversion (Array to List)
                 String[] array = { "hawk", "robin" };
                 List<String> list = Arrays.asList(array); // returns a fixed size list, NOT ArrayList
                 System.out.println(list.size()); // 2
                 list.set(1,"test"); 
                 array[0] = "new"; 
                 for(String b : array) System.out.print(b + " "); 
                 list.remove(1);  // throws UnsupportedOperation Exception 
                 - setting is fine to do to this list but changing the size/ adding or removing is not allowed
        Sorting ::
            ->-> ArrayList sorted using the Collections.sort(someArrayList); will be in ascending order
            ->-> To sort ArrayLists, you use the helper class collections
                    ex.) List<Integer> nums = new ArrayList<>();
                         nums.add(12);
                         nums.add(54); 
                         nums.add(6); 
                         Collections.sort(nums); //this does the sorting
                         System.out.println(nums); // this would print 
    Working with Dates and Times::
            ->-> all date and time classes are able to be used through   import java.time.*;
        Creating Dates and Times ::
            ->-> LocalDate - Contains just a date--no time and no timezone. i.e.) your birthday
                    gives it in this format   2001-01-20
            ->-> LocalTime - Contains just a time--no date and no timezone. i.e.) midnight
                    gives it in this format   24:00:00.000
            ->-> LocalDateTime - Contains both a date and a time but no timezone. i.e.) midnight January 3rd
                    gives it in this format   2001-01-20T24:00:00.000
            ->-> Oracle recommends avoiding time zones unless you really need them
                    If you do need to communicate across time zones, ZonedDateTime handles them
            ->-> Each LocalDate, LocalTime, and LocalDateTime has a static method now() that gives you the current date and time 
            ->-> Examples of creating a LocalDate::
                  --- Method Signatures::
                        - public static LocalDate of(int year, int month, int dayOfMonth)
                        - public static LocalDate of(int year, Month month, int dayOfMonth)
                  --- Examples:: 
                        - LocalDate date1 = LocalDate.of(2015, Month.JANUARY, 20);
                        - LocalDate date2 = LocalDate.of(2015, 1, 20);
                   -- allows for MONTH enums 
            ->-> Examples of creating a LocalTime::
                  --- Method Signatures::
                        - public static LocalTime of(int hour, int minute)
                        - public static LocalTime of(int hour, int minute, int second)
                        - public static LocalTime of(int hour, int minute, int second, int nanos)
                  --- Examples::
                        - LocalTime time1 = LocalTime.of(6, 15); // hour and minute
                        - LocalTime time2 = LocalTime.of(6, 15, 30); // + seconds
                        - LocalTime time3 = LocalTime.of(6, 15, 30, 200); // + nanoseconds
            ->-> Examples of creating a LocalDateTime::
                  --- Method Signatures::
                        - public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)
                        - public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)
                        - public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanos)
                        - public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)
                        - public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)
                        - public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanos)
                        - public static LocalDateTime of(LocalDate date, LocalTime)
                  --- Examples::
                        - LocalDateTime dateTime1 = LocalDateTime.of(2015, Month.JANUARY, 20, 6, 15, 30);
                        - LocalDateTime dateTime2 = LocalDateTime.of(date1, time1);
            ->-> Date and Time classes have private constructors to force you to use the static methods
        Manipulating Dates and Times ::
            ->-> Date and/or Time Methods::
                            Method                         Can call on LocalDate?          Can call on LocalTime?          Can call on LocalDateTime?
             plusDays(int num);/minusDays(int num);                 Yes                             No                                Yes
             plusWeeks(int num);/minusWeeks(int num);               Yes                             No                                Yes   
             plusMonths(int num);/minusMonths(int num);             Yes                             No                                Yes 
             plusYears(int num);/minusYears(int num);               Yes                             No                                Yes 
             plusSeconds(int num);/minusSeconds(int num);           No                              Yes                               Yes  
             plusMinutes(int num);/minusMinutes(int num);           No                              Yes                               Yes 
             plusHours(int num);/minusHours(int num);               No                              Yes                               Yes 
             plusNanos(int num);/minusNanos(int num);               No                              Yes                               Yes 
             
                - isBefore(LocalDateTime) - returns a boolean, can be used on all 
            ->-> LocalDate Methods::    
                - toEpochDay() - returns number of days since January 1, 1970
                - getDayOfWeek() - returns enum i.e.) MONDAY 
                - getMonth() - returns enum i.e.) JANUARY
                - getYear() - returns an int of the LocalDate's year 
                - int getDayOfYear() - returns an int of the LocalDate's day of the year 
            ->-> LocalTime Methods:: 
            ->-> LocalDateTime Methods::
                - toEpochTime() - returns number of seconds since January 1, 1970
        Working with Periods ::
            ->-> Period methods have to be accessed statically just like Dates and Times
            ->-> 5 ways to create a Period::
                - Period annually = Period.ofYears(1); // every 1 year
                - Period quarterly = Period.ofMonths(3); // every 3 months
                - Working with Dates and Times 147
                - Period everyThreeWeeks = Period.ofWeeks(3); // every 3 weeks
                - Period everyOtherDay = Period.ofDays(2); // every 2 days
                - Period everyYearAndAWeek = Period.of(1, 0, 7); // every year and 7 days
            ->-> Period methods cannot be chained, only the final method would be used
            ->-> Periods are a day or more of time 
            ->-> Duration is another class that can be used to specify the number of days, hours, minutes, seconds, or nanoseconds
                            it works roughly the same as a Period 
            ->-> Period classes can only be used with LocalDate or LocalDateTime classes NOT LocalTime classes
        Formatting Dates and Times ::
            ->-> Java provides a class called DateTimeFormatter in the package   java.time.format; 
            ->-> .format(DateTimeFormatter.ISO_LOCAL_TIME) is how you get ISO standard for dates which will look like previous examples 
                            i.e.) 2020-01-20
                                  11:12:34
                                  2020-01-20T11:12:34
            ->-> when using a DateTimeFormatter, to actually apply it, you do the DateTimeFormatterVariableCreated.format(someDateTimeObject)
            ->-> Pre-defined formats::
                - DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
                - DateTimeFormatter mediumF = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);
            ->-> Creating your own format::
                - DateTimeFormatter f = DateTimeFormatter.ofPattern("MMMM dd, yyyy, hh:mm");
                    - MMMM -- M represents the month. The more Ms you have, the more verbose the Java output, 
                                i.e.) M outputs 1, MM outputs 01, MMM outputs Jan, and MMMM outputs January
                    - dd -- d represents the date in the month, the more ds you have, the more verbose the Java output 
                                                dd means to include the leading zero for a single-digit month
                    - , -- Use , if you want to output a comma (this also appears after the year)
                    - yyyy -- y represents the year
                                i.e.) yy outputs a two-digit year and yyyy outputs a four-digit year
                    - hh -- h represents the hour
                             Use hh to include the leading zero if you’re outputting a singledigit hour
                    - : -- Use : if you want to output a colon
                    - mm -- m represents the minute
            ->-> ofLocalized Methods::
                DateTimeFormatter f =                     Calling f.format(localDate)         Calling f.format(localDateTime)         Calling f.format(localTime)
                DateTimeFormatter.__(FormatStyle.SHORT); 
                ofLocalizedDate                           Legal - shows whole object           Legal - shows just date part            Throws runtime exception 
                ofLocalizedDateTime                       Throws runtime exception             Legal - shows whole object              Throws runtime exception 
                ofLocalizedTime                           Throws runtime exception             Legal - shows just time part            Legal - shows whole object 
        Parsing Dates and Times ::
            ->-> This is all you need::
                 DateTimeFormatter f = DateTimeFormatter.ofPattern("MM dd yyyy"); // creates the DateTimeFormatter 
                 LocalDate date = LocalDate.parse("01 02 2015", f); // creates a LocalDate making sure the string matches the type of formatter (String, f)
                 LocalTime time = LocalTime.parse("11:22"); // since there is not DateTimeFormatter, it use the default formatter for this type
                 System.out.println(date); // 2015-01-02
                 System.out.println(time); // 11:22
    Exam Essentials ::
        ->-> Be able to determine the output of code using String 
        ->-> Be able to determine the output of code using StringBuilder
        ->-> Understand the difference between == and equals 
        ->-> Be able to determine the output of code using arrays 
        ->-> Be able to determine the output of code using ArrayList 
        ->-> Recognize invalid uses of dates and times 
Chapter 4 [Methods and Encapsulation]::
    PDF Page: 211
    Designing Methods ::
            ->-> Method Signature::
                    public final void nap(int min) throws Interrupted Exception{
                        //take a nap
                    } 
            ***ORDER MATTERS except between OPTIONAL specifiers***
            ->-> Parts of a method declaration::
                Element             Value in nap() example          Required?
               
                Return type         void                            Yes 
                Method name         nap                             Yes 
                Parameter list      (int min)                       Yes, but can be empty parentheses 
                Optional exception  throws InterruptedException     No
                list 
                Method body         {                               yes, but can be empty braces 
                                        //take a nap
                                    }
        Access Modifiers::
            ->-> There are four access modifiers::
                    public                          - The method can be called from any class 
                    private                         - The method can only be called from within the same class
                    protected                       - The method can only be called from classes in the same package or subclasses 
                    Default(Package Private) Access - The method can only be called from classes in the same package (there is no keyword, you omit the access modifier)
        Optional Specifiers ::
            ->-> Optional specifiers::
                static - used for class methods 
                abstract - used when not providing a method body
                final - used when a method is not allowed to be overriden by a subclass 
                native - used when interacting with code written in another language such as C++
                strictfp - used for making floating-point calculations portable    
        Return Type ::
            ->-> look inside the method body to make sure the return keyword followed by the type matches the type in the method signature 
            ->-> void does not return anything but can still have the return statement within the method as long as there is nothing following it 
        Method Name ::
            ->-> Method names follow the same rules as variable names from Chapter 1 [Java Building Blocks][Declaring and Initializing Variables][Identifiers] 
        Parameter List ::
            ->-> It is perfectly acceptable to have a parameter list without any parameters i.e.) public void method(){}
            ->-> when you have multiple parameters, separate them with a comma i.e.) public String nums(int a, int b, int c){return "" + a + " " + b + " " + c; }
        Optional Exception List ::
            ->-> you can list as many types of exceptions as you want as long as they are separated by commas
                             i.e.) public void twoExceptions() throws IllegalArgumentException, InterruptedException{}
        Method Body ::
            ->-> A code block that contains 0 or more Java statements 
                    (code blocks are defined by the braces after a method signature)
                        i.e.) public void exampleMethod(){ }
            ->-> It will NOT compile without the braces or parameter list 
    Working with Varargs ::
        ->-> A vararg parameter must be the last element in a method's parameter list,
                        implying that you are only allowed to have one vararg parameter per method 
        ->-> They are the ellipses  ... that appear in the parameter list 
        ->-> They have to be the FINAL parameter in the parameter list ALWAYS for the code to compile 
        ->-> There can only be ONE vararg parameter per method parameter list
        ->-> When calling a vararg parameter, you can pass in an array, list the elements of the array and let Java create it for you, or you can even
                            omit the vararg values in the method call and Java will create an array of length zero for you
        ->-> Example::
                15: public static void walk(int start, int... nums) {
                16: System.out.println(nums.length);
                17: }
                18: public static void main(String[] args) {
                19: walk(1); // 0
                20: walk(1, 2); // 1
                21: walk(1, 2, 3); // 2
                22: walk(1, new int[] {4, 5}); // 2
                23: }
        ->-> Accessing a vararg parameter is the same as accessing an array item 
    Applying Access Modifiers ::
            ->-> The four access modifiers::    
                 **private - only accessible within the same class 
                 **default (package private) access - private and other classes in the same package 
                 **protected - default access and child classes 
                 **public - protected and classes in the other packages 
        Private Access ::
            ->-> When classA gets instantiated in classB and attempts to use a method privatized to classA 
                        the code will not compile.  
                - EXAMPLE::
                    1: package pond.duck;
                    2: public class FatherDuck {
                    3:     private String noise = "quack";
                    4:     private void quack() {
                    5:        System.out.println(noise); // private access is ok
                    6: }
                    7: private void makeNoise() {
                    8:        quack(); // private access is ok
                    9: } }
                    -- this works because the quack method was created within the FatherDuck class and is still within it when used 
                    1: package pond.duck;
                    2: public class BadDuckling {
                    3:    public void makeNoise() {
                    4:      FatherDuck duck = new FatherDuck();
                    5:      duck.quack(); // DOES NOT COMPILE
                    6:      System.out.println(duck.noise); // DOES NOT COMPILE
                    7: } }
                    -- This does NOT work because BadDuckling is not the same class as FatherDuck; therefore, it cannot use FatherDuck's methods 
        Default (Package Private) Access ::
            ->-> Default access is when the method has no access modifier 
            ->-> members of the same package can access each other's methods through their associated object 
                    i.e.)  public class GoodDuckling {
                             public void makeNoise() {
                                MotherDuck duck = new MotherDuck();
                                duck.quack(); // default access
                                System.out.println(duck.noise); // default access
                             } 
                           }
                        - if the member is not a part of the same package then it CANNOT access another member's methods from that same package
        Protected Access ::
            ->-> The protected access modifi er adds the ability to access members of a parent class
            ->-> Protected allows access subclasses and classes in the same package to access members in the same package 
                    i.e.)  package pond.inland;
                           import pond.shore.Bird; // different package than Bird
                            public class BirdWatcherFromAfar {
                                public void watchBird() {
                                    Bird bird = new Bird();
                                    bird.floatInWater(); // DOES NOT COMPILE
                                    System.out.println(bird.text); // DOES NOT COMPILE
                                } 
                            }
            ->-> Weird but extrememly IMPORTANT example::
                    1: package pond.swan;
                    2: import pond.shore.Bird; // in different package than Bird
                    3: public class Swan extends Bird { // but subclass of bird
                    4:   public void swim() {
                    5:      floatInWater(); // package access to superclass
                    6:      System.out.println(text); // package access to superclass
                    7:   }
                    8:   public void helpOtherSwanSwim() {
                    9:      Swan other = new Swan();
                    10:     other.floatInWater(); // package access to superclass
                    11:     System.out.println(other.text);// package access to superclass
                    12:  }
                    13:  public void helpOtherBirdSwim() {
                    14:      Bird other = new Bird();
                    15:      other.floatInWater(); // DOES NOT COMPILE
                    16:      System.out.println(other.text); // DOES NOT COMPILE
                    17:  }
                    18: }
                  - the reason the Bird other object does NOT compile is because while it is still within the class Swan, 
                        the Bird object is within its own, separate, package, therefore it CANNOT use protected members 
            ->-> Protected rules under 2 Scenarios::
                    <-> A member is used without reffering to a variable 
                    <-> A member is used through a variable, in this case, the rules for the reference type of the variable are what matter, 
                            - if the same class or a subclass, protected access is allowed 
                            - if not, protected access is NOT allowed 
        Public Access ::
            ->-> any thing can be accessed
        Access Modifier Table::
            Can access                                              private member?             default member?             protected member?           public memnber?
            Member in the same class                                       Yes                          Yes                        Yes                        Yes 
            Member in another class, same package                          No                           Yes                        Yes                        Yes 
            Member in a superclass in a different package                  No                           No                         Yes                        Yes 
            Method/field in a non-superclass in a different package        No                           No                         No                         Yes  
        Designing Static Methods and Fields ::
            ->-> Static methods do NOT require an instance of the class; Think of them as a member that exists independently of any other instances of a class 
            !!!! Does Each Class Have Its Own Copy of the Code? 
                   - Each class has a copy of the instance variables. 
                     There is only one copy of the code for the instance methods. 
                     
                     Each instance of the class can call it as many times as it would like.
                     However, each call of an instance method (or any method) gets space on the stack for method parameters and local variables.
                     
                     The same thing happens for static methods. 
                     There is one copy of the code. Parameters and local variables go on the stack.
                     
                     Just remember that only data gets its “own copy.” 
                     There is no need to duplicate copies of the code itself.
            ->-> You can call static methods and members by the class name without having to create an instance of said class 
            ->-> Static methods 2 main purposes::
                    - For utility or helper methods that don’t require any object state. 
                                Since there is no need to access instance variables, 
                                    having static methods eliminates the need for the caller to instantiate the object just to call the method
                    - For state that is shared by all instances of a class i.e.) a counter
                        All instances must share the same state; Methods that merely use that state should be static as well
        Calling a Static Variable or Method ::
            ->-> To access a static member you just put the classname before the method or variable 
            ->-> Example & Explanation::
                  - System.out.println(Koala.count);
                    Koala.main(new String[0]);
                -- You can also use an instance of the object to call upon the static method;
                        The compiler checks for the type of the reference and uses that instead of the object 
                  - Koala k = new Koala();
                    System.out.println(k.count); // k is a Koala
                    k = null;
                    System.out.println(k.count); // k is still a Koala
                -- This code will output 0 twice; this is due to the fact that Java doesn't care that k is null, 
                                it is only looking for the static modifier 
            ->-> NOTE about null & static::
                 - Remember to look at the reference type for a variable when you see a static method or variable; 
                        the exam creators will try to trick you into thinking a NullPointerException is thrown because the variable happens to be null
            ->-> Regardless of the amount of instances of an object, if there is only ONE static member and all of the instances are changing that member,
                            the FINAL change to that member is it's final result 
                    - ie.) Koala.count = 4;
                           Koala koala1 = new Koala();
                           Koala koala2 = new Koala();
                           koala1.count = 6;
                           koala2.count = 5;
                           System.out.println(Koala.count); // outputs 5 
        Static vs. Instance ::
            ->-> A static member CANNOT call an instance member, nor refer to an instance member 
            ->-> IMPORTANT Example::
                    public class Static {
                        private String name = "Static class";
                        public static void first() { }
                        public static void second() { }
                        public void third() { System.out.println(name); }
                        public static void main(String args[]) {
                            first();
                            second();
                            third(); // DOES NOT COMPILE
                        } 
                    }
                - for the code to compile, you would need to change the third() member to a static one as well as anything it references, such as name 
            ->-> Static vs. instance calls::
                    Type                Calling                                 Legal?        How? 
                    Static method       Another static method or variable       Yes           Using the class name 
                    Static method       An instance method or variable          No 
                    Instance method     A static method or variable             Yes           Using the classname or a reference variable 
                    Instance method     Another instance method or variable     Yes           Using a reference variable 
            ->-> Static variable are automatically initialized to their type's default value 
        Static Variables ::
            ->-> Some static variables are meant to change as the program runs 
            ->-> Some static variables are meant to stay constant during the program,
                    these types of variables use the final modifier to ensure that it never changes,
                        the naming conventions for these types of variables are all UPPERCASE_WITH underscores separating words
                            ie.) public class Initializers {
                                    private static final int NUM_BUCKETS = 45;
                                    public static void main(String[] args) {
                                        NUM_BUCKETS = 5; // DOES NOT COMPILE
                                    } 
                                 }
            ->-> You are allowed to call methods on reference variables 
                    ie.)  private static final ArrayList<String> values = new ArrayList<>();
                          public static void main(String[] args) {
                            values.add("changed"); // this is fine because the values reference is not attempting to point to a different reference 
                          }
        Static Initialization ::
            ->-> the static initializer runs when the class is first used 
                    ie.) static {
                            int something = 2;
                            int k = 12;
                            int wl = 234; 
                         }
            ->-> If final variables are declared rather than initilized, it is perfectly legal to initilize them within the static initializer/ in general, 
                        as long as nothing is attempting to be reassigned
            ->-> NOTE::
                    When you need to initialize a static field and the code to do so requires more than one line, 
                            then it makes sense to use static initializers but try to avoid them 
        Static Imports ::
            ->-> Regular imports are for importing classes, static imports are for importing static members of classes
            ->-> you can use a wildcard or import a specific member 
            ->-> Example::
                    - import java.util.List;
                      import static java.util.Arrays.asList; // static import
                      public class StaticImports {
                        public static void main(String[] args) {
                            List<String> list = asList("one", "two"); // no Arrays. needed 
                        } 
                      }
            ->-> Example with what could go WRONG::
                    - 1: import static java.util.Arrays; // DOES NOT COMPILE because it tries to use a static import to import a class 
                      2: import static java.util.Arrays.asList;
                      3: static import java.util.Arrays.*; // DOES NOT COMPILE because the order of the keywords are wrong | import static not static import 
                      4:    public class BadStaticImports {
                      5:        public static void main(String[] args) {
                      6:          Arrays.asList("one"); // DOES NOT COMPILE because while the asList method was imported successfully, the Arrays nor the List class was imported 
                      7:        } 
                      8:    }
            ->-> the compiler will complain if you try to explicitly do a static import of two methods with the same name or two static variables with the same name
    Passing Data Among Methods ::
        ->-> Java is a "pass-by-value" language meaning that a copy of the variable is made and the method recieves that copy 
        ->-> Example::
                2: public static void main(String[] args) {
                3:      int num = 4;
                4:      newNumber(5);
                5:      System.out.println(num); // 4
                6: }
                7: public static void newNumber(int num) {
                8:      num = 8;
                9: }
              - as there is no reassignment to the variable, newNumber(5) does nothing to the code; 
                public static void main(String[] args) {
                    StringBuilder name = new StringBuilder();
                    speak(name);
                    System.out.println(name); // Webby
                }
                public static void speak(StringBuilder s) {
                    s.append("Webby");
                }
              - since the reference just calls a method, it isn't reassigning anything. 
                    Both s and name point to the SAME StringBuilder, which means that changes made to the StringBuilder are available to both references
        ->-> Assigning a new primitive or reference to a parameter doesn't change the caller
        ->-> Calling methods on a reference object does affect the caller 
        ->-> IMPORTANT::
              - unless you see an = in the main() where a variable is reassigning itself to the method call which returns something, nothing changes 
                    ie.) 1:  public class ReturningValues {
                         2:     public static void main(String[] args) {
                         3:         int number = 1; // 1
                         4:         String letters = "abc"; // abc
                         5:         number(number); // 1      | if there was a number = number(number); then this would evaluate to 2
                         6:         letters = letters(letters); // abcd     | without the = to assign letters to letters(letters), the result would've been abc
                         7:         System.out.println(number + letters); // 1abcd
                         8:     }
                         9:     public static int number(int number) {
                         10:        number++;
                         11:        return number;
                         12:    }
                         13:    public static String letters(String letters) {
                         14:        letters += "d";
                         15:        return letters;
                         16:    }
                         17: }
    Overloading Methods ::
            ->-> Method overloading occurs when there are different method signatures with the same name but different type parameters
            ->-> Everything other than the method signature can vary for overloaded methods 
                    meaning there can be: different access modifiers, specifiers (like static), return types, and exception lists
            ->-> Valid vs Invalid overloaded method examples::
                        ->-> essentially, an overloaded method is only valid if the parameter list changes, otherwise there will be a compiler error
                    Valid overloaded method examples::
                        - public void fly(int numMiles) { }
                        - public void fly(short numFeet) { }
                        - public boolean fly() { return false; }
                        - void fly(int numMiles, short numFeet) { }
                        - public void fly(short numFeet, int numMiles) throws Exception { }
                    Invalid overloaded method examples::
                        - public void fly(int numMiles) { }
                        - public int fly(int numMiles) { } // DOES NOT COMPILE because the return type is the only thing changed, the parameter list is the same 
                        --------------------------------------------------------------------------------------------------------------------------------------
                        - public void fly(int numMiles) { }
                        - public static void fly(int numMiles) { } // DOES NOT COMPILE because the parameter list is the same 
        Overloading and Varargs::
            ->-> Remeber that Java treats varargs similarly to an array so having two methods like this: 
                        public void fly(int[] lengths) { }       and      public void fly(int... lengths) { } would cause a compiler error 
            ->-> However, if you were to have the varargs fly() method, 
                    it could be either called by expressing the parameter as an array or having stand-alone parameters
        Autoboxing::
            ->-> public void fly(int numMiles) { }      and 
                 public void fly(Integer numMiles) { } 
                    are valid overloaded methods BUT when calling fly(3), Java will match with the int version 
                                as it tries to use the most specific parameter list it can find
        *** Java will find the MOST specific match to the method call and use that method *** 
        Putting It All Together::
                ->-> autoboxing and varargs come last when Java looks at overloaded methods 
                ->-> Order Java uses to choose the right overloaded method::
                        Rule                    Example of what will be chosen for glide(1,2) 
                        Exact match by type     public String glide(int i, int j) {}
                        Larger primitive type   public String glide(long i, long j) {}
                        Autoboxed type          public String glide(Integer i, Integer j) {}
                        Varargs                 public String glide(int... nums) {}
                ->-> Java will only do one conversion with trying to find a match
                        ie.) public class TooManyConversions {
                                public static void play(Long l) { }
                                public static void play(Long... l) { }
                                public static void main(String[] args) {
                                    play(4); // DOES NOT COMPILE because Java has to convert the int to a long and then to a Long, 
                                             //          it's willing to convert from int to long, BUT not do a second conversion from long to Long
                                    play(4L); // calls the Long version
                                } 
                            }
    Creating Constructors ::    
            ->-> A constructor is a special method that matches the name of the class and has no return type 
            ->-> Constructors are used when creating a new object, this is called instantiation 
            ->-> When Java sees the new keyword, it allocates memory for the new object
            ->-> If you don’t say otherwise, Java gives you the one with the smallest scope, which is the parameter
                         Using this.name tells Java you want the instance variable
            ->-> Example ::
                    1: public class Bunny {
                    2:    private String color;
                    3:    public Bunny(String color) {
                    4:       this.color = color;
                    5:    } 
                    6: }
        Default Constructor ::
            ->-> Every class in Java has a constructor whether you code one or not, 
            ->-> When you don't include any constructors in the class, Java creates one for you WITHOUT any parameters 
            ->-> The default constructor has an empty parameter list and an empty body, you may type this in yourself if wanted. 
            ->-> Java generates the default constructor (when you haven't included any) and it will only be in the compiled file (the .class) NOT the .java 
        Overloading Constructors ::
            ->-> You can have multiple constructors per class as long as they have different method signatures/ different parameter lists 
            ->-> Example ::
                    public class Hamster {
                        private String color;
                        private int weight;
                        public Hamster(int weight) { // first constructor
                            this.weight = weight;
                            color = "brown";
                        }
                        public Hamster(int weight, String color) { // second constructor
                            this.weight = weight;
                            this.color = color;
                        }
                    }
            ->-> Constructors can be called only by writing new before the name of the constructor 
            ->-> You are able to use the this keyword to call another constructor on the same instance of the class 
                    ie.) public Hamster(int weight) {
                            this(weight, "brown"); 
                         }
                         public Hamster(int weight, String color){
                            this.weight = weight; 
                            this.color = color; 
                         }
                 ***NOTE*** if you use this(), you need to know that it HAS to be the FIRST noncommented statement in the constructor 
        Constructor Chaining (Copied straight from the document but important note and example)::
           Overloaded constructors often call each other. One common technique is to have each
           constructor add one parameter until getting to the constructor that does all the work.
           This approach is called constructor chaining. In this example, all three constructors are chained.
            public class Mouse {
                private int numTeeth;
                private int numWhiskers;
                private int weight;
              public Mouse(int weight) {
                this(weight, 16); // calls constructor with 2 parameters
              }
              public Mouse(int weight, int numTeeth) {
                this(weight, numTeeth, 6); // calls constructor with 3 parameters
              }
              public Mouse(int weight, int numTeeth, int numWhiskers) {
                this.weight = weight;
                this.numTeeth = numTeeth;
                this.numWhiskers = numWhiskers;
              }
              public void print() {
                System.out.println(weight + " " + numTeeth + " " + numWhiskers);
              }
              public static void main(String[] args) {
                Mouse mouse = new Mouse(15);
                mouse.print();
              }
            }
            This code prints 15 16 6. The main() method calls the constructor with one parameter. That constructor adds a second hard-coded value and calls the constructor with two
            parameters. That constructor adds one more hard-coded value and calls the constructor
            with three parameters. The three-parameter constructor assigns the instance variables.
        Final Fields ::     
            ->-> The constructor is part of the initialization process, so it is allowed to assign final instance variables in it
            ->-> By the time the constructor completes, all final instance variables must have been set
        Order of Initialization ::
            ->-> Order of Initialization::
                    1. If there is a superclass, initialize it first
                    2. Static variable declarations and static initializers in the order they appear in the file
                    3. Instance variable declarations and instance initializers in the order they appear in the file 
                    4. The constructor
            ->-> Easier to Understand Example ::
                 1:  public class InitializationOrderSimple {
                 2:     private String name = "Torchie";
                 3:     { System.out.println(name); }
                 4:     private static int COUNT = 0;
                 5:     static { System.out.println(COUNT); }
                 6:     static { COUNT += 10; System.out.println(COUNT); }
                 7:     public InitializationOrderSimple() {
                 8:         System.out.println("constructor");
                 9:     } 
                 10: }
                 -----------------------------------------------------
                 1: public class CallInitializationOrderSimple {
                 2:   public static void main(String[] args) {
                 3:     InitializationOrderSimple init = new InitializationOrderSimple();
                 4:   } 
                 5: }
                    - outputs::
                      0             //static initializer call
                      10            //another static initializer call that comes after the first static initializer 
                      Torchie       //instance initializer call 
                      constructor   // constructor gets run
                -- Rule 1 doesn't apply here, Rule 2 says to run the static members, Rule 3 says to run the instance members, and Rule 4 says to run the constructor                
            ->-> Harder to Understand Example (IMPORTANT INFO INSIDE)::
                 1: public class InitializationOrder {
                 2:   private String name = "Torchie";
                 3:   { System.out.println(name); }
                 4:   private static int COUNT = 0;
                 5:   static { System.out.println(COUNT); }
                 6:   { COUNT++; System.out.println(COUNT); }
                 7:   public InitializationOrder() {
                 8:     System.out.println("constructor");
                 9:   }
                 10:  public static void main(String[] args) {
                 11:    System.out.println("read to construct");
                 12:    new InitializationOrder();
                 13:  }
                 14: }
                    - output::
                      0                     
                      read to construct 
                      Torchie 
                      1
                      constructor 
                  -- Rule 1 doesn't apply, Rule 2 says to look at the static members, Rule 3 says to run the instance members and Rule 4 says to run the constructor
                *******once the static members are gone, the main() can run*********
    Encapsulating Data ::
            ->-> Encapsulation means we set up the class so only methods in the class with the variables can refer to the instance variables 
                    - callers are required to use these methods 
            ->-> Example ::
                 1:  public class Swan {
                 2:   private int numberEggs; // private       
                 3:   public int getNumberEggs() { // getter/ accessor method | allows us to access the private member numberEggs
                 4:     return numberEggs;
                 5:   }
                 6:   public void setNumberEggs(int numberEggs) { // setter/ mutator method | allows us to modify the private member numberEggs 
                 7:     if (numberEggs >= 0) // guard condition  | allows us to make sure that a valid number is assigned to the numberEggs variable 
                 8:         this.numberEggs = numberEggs;
                 9:   } 
                 10: }
            ->-> Rules for JavaBeans naming conventions::
                 Rule                                                               Example 
                 Properties are private                                             private int numEggs;

                 Getter methods begin with is if the property is a boolean          public boolean isHappy() {
                                                                                        return happy; 
                                                                                    }
                 Getter methods begin with get if the property is not a boolean     public int getNumEggs() { 
                                                                                        return numEggs;
                                                                                    }
                 Setter methods begin with set                                      public void setHappy(boolean happy){
                                                                                      this.happy = happy  
                                                                                    }
                 the method name must have a prefix of set/get/is,                  public void setNumEggs(int num){
                 followed by the first letter of the property in uppercase,             numEggs = num; 
                 followed by the rest of the property name                          }
        Creating Immutable Classes ::
            ->-> One way to create an immutable class is to omit the setter method, 
                    only having a constructor to specify an initial value and getter to access the member 
            ->-> To make sure that we don't pass the same reference in as our parameter and have it still be mutable,
                        we create a copy of said mutable reference called a defensive copy. 
            ->-> Example with defensive copy and one with getter method::
                  <-> defensive copy  
                    public Mutable(StringBuilder b) {
                        builder = new StringBuilder(b);
                    }
                    public StringBuilder getBuilder() {
                        return new StringBuilder(builder);
                    }
                  <-> getter method returning immutable object 
                    public String getValue() {
                        return builder.toString();
                    }
    Writing Simple Lambdas ::
            ->-> Functional Programming is a way of writing code more declaratively, specifying what you want to do rather than dealing with the state of objects 
            ->-> A lambda expression is a block of code that gets passed around, 
                        think of it like an anonymous method 
            ->-> Lambdas have parameters and a body BUT do NOT have a name
            ->-> Lambda expressions are often referred to as lambdas 
            ->-> Lambdas work with interfaces that have ONLY one method called functional interfaces (simplified for OCA exam)
        Lambda Example ::
            ->-> Example ::
                1: public class TraditionalSearch {
                2:  public static void main(String[] args) {
                3:      List<Animal> animals = new ArrayList<Animal>(); // list of animals
                4:      animals.add(new Animal("fish", false, true));
                5:      animals.add(new Animal("kangaroo", true, false));
                6:      animals.add(new Animal("rabbit", true, false));
                7:      animals.add(new Animal("turtle", false, true));
                8:
                9:      print(animals, new CheckIfHopper()); // pass class that does check
                10:  }
                11:  private static void print(List<Animal> animals, CheckTrait checker) {
                12:     for (Animal animal : animals) {
                13:         if (checker.test(animal))                   // the general check
                14:             System.out.print(animal + " ");
                15:     }
                16:     System.out.println();
                17:  }
                18: }
             --- with lambdas we can replace line 9 with print(animals, a -> a.canHop()); 
              -- if we wanted to check if it could swim, it would be replaced with print(animals, a -> a.canSwim()); 
              -- what about cannot swim?  print(animals,, a -> ! a.canSwim()); 
            ->-> Deferred execution means that code is specified now but will run later 
        Lambda Syntax ::
            ->-> Simplest lambda expression ---  a -> a.canHop(); 
            *** How Java knows what methods to use with what object (copy and pasted)::
                    Java replies on context when figuring out what lambda expressions mean
                    We are passing this lambda as the second parameter of the print() method
                    That method expects a CheckTrait as the second parameter
                    Since we are passing a lambda instead, Java tries to map our lambda to that interface:
                                boolean test(Animal a);
                    Since that interface’s method takes an Animal, that means the lambda parameter has to be an Animal
                    Since that interface’s method returns a boolean, we know the lambda returns a boolean
            ->-> Lambda syntax omitting optional parts::
                    a -> a.canHop();
                  - Specify a single parameter with the name a 
                  - The arrow operator to separate the parameter and body 
                  - A body that calls a single method and returns the result of that method 
            ->-> Lambda syntax with optional parts::
                    (Animal a) -> { return a.canHop(); }
                  - Specify a single parameter with the name a and stating the type is Animal 
                        (can only be omitted if there is a single parameter and its type is not explicitly stated)
                  - The arrow operator to separate the parameter and body
                  - A body that has one or more lines of code, including a semicolon and a return statement 
                        (These are required if it is within a code block) 
                        (when braces are omitted, you aren't required to type return or use a semicolon !!!This does NOT work if there are two or more statements)
            ->-> Valid lambdas::
                 - print(() -> true); // 0 parameters
                 - print(a -> a.startsWith("test")); // 1 parameter
                 - print((String a) -> a.startsWith("test")); // 1 parameter
                 - print((a, b) -> a.startsWith("test")); // 2 parameters
                 - print((String a, String b) -> a.startsWith("test")); // 2 parameters
            ->-> Invalid lambdas::
                 - print(a, b -> a.startsWith("test")); // DOES NOT COMPILE because it is missing parentheses 
                 - print(a -> { a.startsWith("test"); }); // DOES NOT COMPILE because it is missing a return statement 
                 - print(a -> { return a.startsWith("test") }); // DOES NOT COMPILE because it is missing a semicolon after a.startsWith("test") 
            ->-> Lambdas are allowed to access instance and static variables; 
                    method parameters and local variables are fine if they are not assigned new values
            **** You cannot redeclare variables within lambda expressions
        Predicates ::
            ->-> Essentially it is a type of interface that can take in any reference (through generics) and allow lambdas to work through it
            ->-> It is in the package     java.util.function   and looks something like this 
                            public interface Predicate<T> {
                                boolean test(T t);
                            } 
                    - <T> is a generic
                    - boolean test(T t) is a made up method that passes in the generic as a parameter for said method 
            ->-> Example::
                    1: import java.util.*;
                    2: import java.util.function.*;
                    3: public class PredicateSearch {
                    4:  public static void main(String[] args) {
                    5:      List<Animal> animals = new ArrayList<Animal>();
                    6:      animals.add(new Animal("fish", false, true));
                    7:
                    8:      print(animals, a -> a.canHop());
                    9:  }
                    10: private static void print(List<Animal> animals, Predicate<Animal> checker) {
                    11:     for (Animal animal : animals) {
                    12:         if (checker.test(animal))
                    13:             System.out.print(animal + " ");
                    14:     }
                    15:     System.out.println();
                    16:  }
                    17: }
            ->-> ArrayList has a removeIf() method that takes a Predicate ::
                    3: List<String> bunnies = new ArrayList<>();
                    4: bunnies.add("long ear");
                    5: bunnies.add("floppy");
                    6: bunnies.add("hoppy");
                    7: System.out.println(bunnies); // [long ear, floppy, hoppy]
                    8: bunnies.removeIf(s -> s.charAt(0) != 'h');
                    9: System.out.println(bunnies); // [hoppy]
    Exam Essentials ::
        ->-> Be able to identify correct and incorrect method declarations 
        ->-> Identify when a method or field is accessible 
        ->-> Recognize valid and invalid uses of static imports 
        ->-> State the output of code involving methods 
        ->-> Evaluate code involving constructors 
        ->-> Be able to recognize when a class is properly encapsulated 
        ->-> Write simple lambda expressions 
Chapter 5 [Class Design]::
    PDF Page: 279
        ->-> Java supports ONLY single inheritance although, you can implement from multiple interfaces // will be explained
        ->-> classes that inherit from another class are often called a child class, or descendent of that class
        ->-> the class the child inherits from is referred to as the parent class, or ancestor class. 
        ->-> you CANNOT inherit from a class with the final modifier
    Introducting Class Inheritance ::
        Extending a Class ::
            ->-> Defining and extending a class : 
                    access modifier         keyword(optional)       class keyword(required)         class name      extends keyword parentclass(optional)
                    public                  abstract or final       class                           Elephant        extends animal

                    ie.) public class Elephant extends Animal{
                            // Methods and Variables defined in here
                         }
            ->-> the extends keyword is IMPORTANT, you CANNOT have a subclass/child class if it doesn't extend some other class
            ->-> the child class has access to any public methods and variables from the parent class
                    it CANNOT access any private variables
            ->-> PERSONAL SIDE NOTE:: 
                    think of it like, you have a big container with a little container  
                            the big container can be set = to a same size container (aka the same parent object's constructor) 
                            or  
                            the bigger container can be set = to something smaller, like a little container ( aka the child object's constructor)
        Applying Class Access Modifiers ::
            ->-> There can only be one public class per file and that public class HAS to be the file name 
                    there can be many default (meaning no access modifier applied) classes per file 
                        and there can even be no public classes at all per file but if there is a public class  
                            it MUST be the only one of the file 
        Creating Java Objects ::
            ->-> All classes inherit from the class Object (java.lang.Object) and it has no parent class
            ->-> Code Equivalents ::
                    public class Zoo{} is the same as public class Zoo extends java.lang.Object{}
                    - Java automatically adds this extends java.lang.Object syntax when defining a class 
                    - HOWEVER, when you define a new class that extends any other class, Java does NOT add this syntax 
        Defining Constructors ::
            ->-> the first statement of every constructor is either a call to another constructor within the class,
                 using this(), or a call to a constructor in the direct parent class, using super(). 
                 // this may seem confusing and hopefully this side note will help or someone will have a visualization of this
                 SIDE NOTE:     
                    this() - so, regardless of what you are doing in the constructor, 
                            the this() keyword HAS to be the first thing typed IF you are using this() 
                        this() refers to some default constructor of the class you are in, that has no arguments in the parenthesis
                    super() - on the other side of things is super(). super() is similar to this() in that 
                                    it HAS to be the first line of a constructor
                            BUT, super() refers to the DIRECT parent class's constructor, 
                                what this means is the class you are in that extends a parent class, will call the parent class's constructor
                                    ie.) public class Sven extends Animal{
                                        super() // this will point to the Animal class's constructor now that matches the amount of arguments passed in
                                                //  so look for things that match. if it has no arguments it is the default constructor 
                                    } 
                  ****KEEP IN MIND****
                        super() and this() CANNOT be used in the same constructor
            ->-> you CANNOT have multiple super() or this() calls in one constructor. only one ( either this() or super() ) per constructor                   
            ->-> child constructors do NOT have to match parent constructors
                    - as long as the super() call matches the parent constructor, it is fine
        Understanding Compiler Enhancements: 
            ->-> the Java compiler automatically inserts a call to the no-argument constructor super()
                  ie.) THESE ARE ALL EQUIVALENT:
                    - public class Donkey{
                
                      }
                    - public class Donkey{
                         public Donkey(){

                         }
                      }
                    - public class Donkey{
                        public Donkey(){
                            super(); 
                        }
                      }
            ->-> In the event the parent class does NOT have a no-argument constructor:: 
                    when a child class extend a class, you must define the child class's constructor(s)
                    to have a super call that matches the parent class's constructor's arguments
                    - without an explicit call to the parent class's constructor,
                         the child class's constructors will attempt to call the no-argument super() class constructor 
                         this will throw a compiler error 
            ->-> Constructor Rules ::
                 1.) The first statement of every constructor is a call to another constructor within the class
                     using this(), or a call to the direct parent class constructor using super(); 
                 
                 2.) The super() call may not be used after the first statement of the constructor 
                 
                 3.) If no super() call is declared in a constructor, 
                     Java will insert a no-argument super() as the first statement of the constructor

                 4.) If the parent DOESNT have a no-argument constructor and the child DOESNT define any 
                     constructors, the compiler will throw an error and try to insert a default no-argument 
                     constructor into the child class 
                
                 5.) If the parent DOESNT have a no-arguemnet constructor, 
                     the compiler requires an explicit call to a parent constructor in each child constructor 
        Calling Constructors:: 
            ->-> EXAMPLE [the example is very much so needed]
                 class Primate {
                    public Primate() {
                        System.out.println("Primate");
                    }
                 }
                
                 class Ape extends Primate {
                    public Ape() {
                        System.out.println("Ape");
                    }
                 }
                
                 public class Chimpanzee extends Ape {
                    public static void main(String[] args) {
                        new Chimpanzee(); // this will print out 
                            // Primate 
                            // Ape 
                    }
                 }
                 - so this is what is happening :: 
                        the compiler inserts a super() command as the first statement of both
                         the Primate and Ape constructors (remember top to bottom, left to right)
                        Then, it inserts a default no-argument constructor for the Chimpanzee class
                             with super() as the first statement of that constructor 
                        Then the code executes the parent constructors called first,
                         (which is why the before mentioned top to bottom etc.)
                            (Primate being the indirect parent of Chimpanzee because Chimpanzee extends Ape
                                and then Ape extends Primate)     
        Calling Inherited Class Members ::
            ->-> IF the parent class and child class are in the same package,
                    the child class may use any default members defined in the parent class 
            ->-> The this keyword and super keyword may both be used for methods and variables defined in the parent class 
                        (as long as you are in the child class) 
                    but the child class CANNOT use both keywords, only the this keyword is applicable 
        Inheriting Methods ::
            ->-> Inheriting a class grants us access to the public and protected members of the parent class, BUT 
                    sets the stage for collisions between methods defined in both the parent class and the subclass 
        Overriding a Method ::
            ->-> When there is a method defined in both the parent and child class you override the method 
            ->-> Overriding a method is declaring a new method with the same signature and return type as the method in the parent classes
            ->-> When overriding a method, you can reference the parent version of the method using the super keyword   
                        ie.) public class Canine {
                                public double getAverageWeight() {
                                    return 50;
                                }
                             }
                             public class Wolf extends Canine {
                                public double getAverageWeight() {
                                    return super.getAverageWeight()+20; // the subclass references the parent class's getAverageWeight() method 
                                }
                                public static void main(String[] args) {
                                    System.out.println(new Canine().getAverageWeight());  // 50.00
                                    System.out.println(new Wolf().getAverageWeight());    // 70.00
                                }
                             }
                ->-> Without the super call within the child class in reference to the parent class you get an infinite loop,
                                the Java compiler thinking you were trying to execute a recursive call
                                    ie.) public double getAverageWeight() {
                                            return getAverageWeight()+20; // INFINITE LOOP
                                         }
                ->-> Checks the compiler performs when you override a nonprivate method ::
                        1. The method in the child class must have the same signature as the method in the parent class. 
                        2. The method in the child class must be at least as accessible or more accessible than the method in the parent class 
                        3. The method in the child class may not throw a checked exception that is new 
                                        or broader than the class of any exception thrown in the parent class method
                        4. If the method returns a value, it must be the same or a subclass of the method in the parent class, known as covariant return types 
                ->-> Overloading vs. Overriding ::
                        - An overloaded method will use a different signature than an overridden method 
                        - Example:: 
                            public class Bird {
                              public void fly() {
                                System.out.println("Bird is flying");
                              }
                              public void eat(int food) {
                                System.out.println("Bird is eating "+food+" units of food");
                              }
                            }
                            
                            public class Eagle extends Bird {
                              public int fly(int height) {
                                System.out.println("Bird is flying at "+height+" meters");
                                return height;
                              }
                              public int eat(int food) { // DOES NOT COMPILE because it tries to change the return type-
                                                         //  -making it an unsuccessful attempt to override the parent's method 
                                System.out.println("Bird is eating "+food+" units of food");
                                return food;
                              }
                            }
                ->-> A child method may hide or eliminate a parent method's exception without issue (NOT vice versa)
                ->-> A child method CANNOT throw a broader scoped exception than the parent class's method
                        nor can it throw an exception that IS NOT a subclass of the parent class's exception 
                ->-> Example:: 
                            public class Reptile {
                                protected double getHeight() throws InsufficientDataException {
                                   return 2;
                                }
                                protected int getLength() {
                                    return 10;
                                }
                            }
                                 
                            public class Snake extends Reptile {
                                protected double getHeight() throws Exception { // DOES NOT COMPILE because Exception is not a subclass of InsufficientDataException
                                    return 2;
                                }
                                protected int getLength() throws InsufficientDataException { // DOES NOT COMPILE because a new exception is being defined,
                                                                                                //   therefore a VIOLATION of the 3rd rule of overriding methods 
                                    return 10;
                                }
                            }
        Redeclaring private Methods ::
                ->-> Java permits you to redeclare a new method in the child class with the same or modified signature as the method in the parent class 
                        IF that method in the parent class is private as there would be no world in which the child class could be able to acces that method 
                ->-> Example ::
                    public class Camel {
                        private String getNumberOfHumps() {
                            return "Undefined";
                        }
                    }
                    public class BactrianCamel extends Camel {
                        private int getNumberOfHumps() {          // perfectly valid since the parent method is private 
                            return 2;
                        }
                    }
        Hiding Static Methods ::
                ->-> A hidden method occurs when a child defines a static method with the same name and signature as a static method defined in a parent class
                ->-> 5 rules for hiding a method ::
                        1. The method in the child class must have the same signature as the method in the parent class
                        2. The method in the child class must be at least as accessible or more accessible than the method in the parent class 
                        3. The method in the child class may not throw a checked exception that is new or
                                 broader than the class of any exception thrown in the parent class method 
                        4. If the method returns a value, it must be the same or a subclass of the method in the parent class, known as covariant return types
                        5. The method defined in the child class must be marked as static if it is marked as static in the parent class (method hiding) 
                                The method must not be marked as static in the child class if it is not marked as static in the parent class (method overriding)
                ->-> Example with a violation of the 5th rule ::
                        public class Bear {
                          public static void sneeze() {
                            System.out.println("Bear is sneezing");
                          }
                          public void hibernate() {
                            System.out.println("Bear is hibernating");
                          }
                        }
                        public class Panda extends Bear {
                          public void sneeze() { // DOES NOT COMPILE because the compiler detects an attempt to override a method that should be hidden
                                                 //     sneeze() is marked as static in the parent class but not in the child class 
                            System.out.println("Panda bear sneezes quietly");
                          }
                          public static void hibernate() { // DOES NOT COMPILE because the compiler thinks you're trying to hide a method that should be overridden
                                                           //   hibernate() is an instance method in the parent class but a static method in the child class 
                            System.out.println("Panda bear is going to sleep");
                          }
                        }
        Overriding vs. Hiding Methods :: 
                ->-> Hidden methods only replace parent methods in the calls defined in the child class
                        overriding a method has a child method replacing the parent method in calls defined in BOTH the parent and child
                ->-> At runtime the child version of an overridden method is always executed for an instance 
                            regardless of whether the method call is defined in a parent or child class method;
                                this means the parent method will never be used unless an explicit call to it is made 
                ->-> At runtime the parent version of the hidden method is ALWAYS executed if the call to the method is DEFINED in the parent class 
                ->-> Example of how this works::
                    public class Marsupial {
                        public static boolean isBiped() {
                            return false;
                        }
                        public void getMarsupialDescription() {
                            System.out.println("Marsupial walks on two legs: "+isBiped());
                        }
                    }
                    public class Kangaroo extends Marsupial {
                        public static boolean isBiped() {
                            return true;
                        }
                        public void getKangarooDescription() {
                            System.out.println("Kangaroo hops on two legs: "+isBiped());
                        }
                        public static void main(String[] args) {
                            Kangaroo joey = new Kangaroo();
                            joey.getMarsupialDescription();   //  Marsupial walks on two legs: false
                            joey.getKangarooDescription();    //  Kangaroo hops on two legs: true 
                        }
                    }
                    - if the methods were NOT static, meaning there technically was NOT an explicit call to them (the isBiped() method) 
                                then the output would be :
                                        Marsupial walks on two legs: true
                                        Kangaroo hops on two legs: true 
                                making the isBiped() method overridden rather than hidden, in the child class
        Creating final methods ::
            ->-> Final methods CANNOT be overridden 
            ->-> You CANNOT hide a static method in a parent class if it is marked as final 
            ->-> Example:: 
                    public class Bird {
                      public final boolean hasFeathers() {
                        return true;
                      }
                    }
                    public class Penguin extends Bird {
                      public final boolean hasFeathers() { // DOES NOT COMPILE because the parent class already marked the method as final 
                        return false;
                      }
                    }
            ->-> The final modifier is only used on methods when the author of the parent method wants to guarantee very precise behaviour,
                        not commonly used in practice though
        Inheriting Variables ::
            ->-> Java does NOT allow variables to be overridden but instead hidden 
        Hiding Variables ::
            ->-> When you hide a variable, you define a variable with the same name as a variable in a parent class, 
                        creating two copies of the variable within an instance of the child class:
                            one instance defined for the parent reference and the other for the child reference 
            ->-> If you're referencing the variable from within the parent class, the variable defined in the parent class is used 
            ->-> If you're referencing the variable from within the child class, the variable defined within the child class is used 
            ->-> You can reference the parent value of the variable with the explicit use of the keyword super
            ->-> Example ::
                    public class Rodent {
                      protected int tailLength = 4;
                      public void getRodentDetails() {
                        System.out.println("[parentTail="+tailLength+"]");
                      }
                    }
                    
                    public class Mouse extends Rodent {
                      protected int tailLength = 8;  // copy of the variable from the parent class (same name) 
                      public void getMouseDetails() {
                        System.out.println("[tail="+tailLength +",parentTail="+super.tailLength+"]"); // super call to use the parent class's variable 
                      }
                      public static void main(String[] args) {
                        Mouse mouse = new Mouse();
                        mouse.getRodentDetails();  // [parentTail=4]
                        mouse.getMouseDetails();   // [tail=8,parentTail=4]
                      }
                    }
    Creating Abstract Class ::
            ->-> An abstract class is a class that is marked with the abstract keyword and
                    CANNOT be instantiated 
            ->-> An abstract method is a method marked with the abstract keyword defined in an abstract class, 
                    for which no implementation is provided in the class in which it is declared 
            ->-> Example ::
                    public abstract class Animal {
                      protected int age;
                      public void eat() {
                        System.out.println("Animal is eating");
                      }
                      public abstract String getName(); // makes sure any class that extends it is forced to implement the getName() method 
                    }
                    
                    public class Swan extends Animal {
                      public String getName() {  // the implementation of said abstract method 
                        return "Swan";
                      }
                    }
        Defining an Abstract Class ::
            ->-> An abstract class may include nonabstract methods and variables
            ->-> An abstract mclass is NOT required to include any abstract methods 
                    ie.) the following compiles :: 
                                public abstract class Cow {
                                }       
            ->-> An abstract method may ONLY be defined in an abstract class 
                    ie.) the following does NOT compile ::
                            public class Chicken {
                              public abstract void peck(); // DOES NOT COMPILE because the class is NOT abstract as well 
                            }
            ->-> Example of NOT compiling:: 
                    public abstract class Turtle {
                      public abstract void swim() {} // DOES NOT COMPILE because there are two brackets instead of a semicolon
                      public abstract int getAge() { // DOES NOT COMPILE because it provides a body to the abstract METHOD 
                        return 10;
                      }
                    } 
            **** Default Method Implementations in Abstract Classes ::
                    Although you can’t provide a default implementation to an abstract method in an abstract class, 
                        you can still define a method with a body; you just can’t mark it as abstract
                        As long as you do not mark it as final, the subclass still has the option to override it
            ->-> An abstract class CANNOT be marked final as by definition it must be extended by another class to be instantiated 
                        whereas a final class can't be extended by another class 
                        ** if you mark an abstract class as final, the compiler refuses to process the code 
            ->-> An abstract method CANNOT be marked final for the same reason as an abstract class, 
                    once marked as final, the method can NEVER be overridden in a subclass,
                            making it impossible to create a concrete instance
            ->-> A method CANNOT be marked as BOTH abstract and private
            ->-> Examples ::
                    - public final abstract class Tortoise { // DOES NOT COMPILE because the class is labeled as final
                      }
                    
                    - public abstract class Goat {
                        public abstract final void chew(); // DOES NOT COMPILE because the method is marked as final 
                      }
                    
                    - public abstract class Whale {
                        private abstract void sing(); // DOES NOT COMPILE because the method is marked as private 
                      }
                    
                      public class HumpbackWhale extends Whale {
                        private void sing() {
                          System.out.println("Humpback whale is singing");
                        }
                      }
                    - public abstract class Whale {
                        protected abstract void sing();
                      }
                      public class HumpbackWhale extends Whale {
                        private void sing() { // DOES NOT COMPILE because the subclass's method attempt to reduce the visibility of the parent method 
                                              //      overridding rules must still be followed even if the method/ class is abstract 
                          System.out.println("Humpback whale is singing");
                        }
                      }
        Creating a Concrete Class :: 
            ->-> A concrete class is the FIRST nonabstract subclass that extends an abstract class,
                        and is REQUIRED to implement ALL inherited abstract methods 
                            (essentially giving body to the methods within the abstract class )
            ->-> Examples :: 
                 - public abstract class Animal {
                    public abstract String getName();
                   }
                    
                   public class Walrus extends Animal { // DOES NOT COMPILE because it does NOT implement ALL of the abstract methods from the extended abstract class
                   }
                 
                 - public abstract class Animal {
                    public abstract String getName();
                   }
                    
                   public class Bird extends Animal { // DOES NOT COMPILE because it needs to implement the abstract methods from the extended abstract class 
                                                      //    since it is the FIRST nonabstract class that extends an abstract class (concrete class)
                   }
                    
                   public class Flamingo extends Bird {
                    public String getName() {
                      return "Flamingo";
                    }
                   }
        Extending an Abstract Class ::
            ->-> The FIRST concrete class MUST implement ALL inherited abstract methods not defined in a parent class 
                    meaning any extending abstract classes' methods must be implemented
            ->-> Abstract Class Definition Rules::
                    1. Abstract classes CANNOT be instantiated directly
                    2. Abstract classes may be defined with any number, including zero, of abstract and nonabstract methods
                    3. Abstract classes may NOT be marked as private or final 
                    4. An abstract class that extends another abstract class inherits all of its abstract methods as its own abstract methods
                    5. The first concrete class that extends an abstract class MUST provide an implementation for ALL of the inherited abstract methods
            ->-> Abstract Method Definition Rules:: 
                    1. Abstract methods may ONLY be defined in abstract classes 
                    2. Abstract methods may NOT be declared private or final 
                    3. Abstract methods must NOT provide a method body/implementation in the abstract class in which it was declared 
                    4. Implementing an abstract method in a subclass follows the same rules for overriding a method 
            ->-> Examples ::
                  - public abstract class Animal {
                        public abstract String getName();
                    }
                    
                    public class Walrus extends Animal { // DOES NOT COMPILE because it is a concrete class; therefore,
                                                         //  it must implement all methods of the extended abstract class 
                    }
                    
                    public abstract class Eagle extends Animal {
                    }
                 
                  - public abstract class Animal {
                        public abstract String getName();
                    }
                    
                    public abstract class BigCat extends Animal {
                        public abstract void roar();
                    }
                    
                    public class Lion extends BigCat {
                        public String getName() { // getName() is from the abstract class Animal 
                            return "Lion";
                        }
                        public void roar() {  // roar() is from the abstract class BigCat
                            System.out.println("The Lion lets out a loud ROAR!");
                        }
                    }
                  
                  - public abstract class Animal { // this example shows how you can have an intermediary abstract subclass provide implementation for 
                                                   //   the parent class's method, making it possible for the subsequent concrete class to 
                                                   //       ONLY have to provide implementation for the abstract method within the subclass 
                                                   //               that does NOT have implementation 
                        public abstract String getName();
                    }
                    
                    public abstract class BigCat extends Animal {
                        public String getName() {
                            return "BigCat";
                        }
                        public abstract void roar();
                    }
                    
                    public class Lion extends BigCat {
                        public void roar() {
                            System.out.println("The Lion lets out a loud ROAR!");
                        }
                    }
    Implementing Interfaces :: 
            ->-> An interface is an abstract data type that defines a list of abstract public methods
                     that ANY class implementing the interface MUST provide,
                      it can include a list of constant variables and default methods
            ->-> Defining an interface ::
                // assumed meaning that whether you put them or not, the compiler will automatically insert them as part of the method definition
                    public abstract interface CanBurrow {
                        public static final int MINIMUM_DEPTH = 2; 

                        public abstract int getMaximumDepth(); 
                    }

                    public              abstract                             interface                      CanBurrow {}
                    [access modifier]   [assumed abstract keyword(assumed)]  [interface keyword (required)] [interface name]

                    public static final             int MINIMUM_DEPTH = 2; 
                    [public static final(assumed)]

                    public abstract                         int getMaximumDepth()
                    [public abstract keywords (assumed)]
            ->-> Implementing an interface ::
                 public class FieldMouse implements CanBurrow { // the implements keyword is required (placement within the signature and spelling)
                        public int getMaximumDepth(){ // signature matches interface method 
                            return 10; 
                        }
                 }
            ->-> multiple interfaces are separated by commas 
                    ie.) public class Elephant implements WalksOnFourLegs, HasTrunk, Herbivore {
                         }
        Defining an Interface ::
            ->-> Rules for creating an interface::
                    1. Interfaces CANNOT be intantiated directly 
                    2. An interface is not required to have any methods 
                    3. An interface may NOT be marked as final 
                    4. ALL top-level interfaces are assumed to have public or default access, and they must include the abstract modifier in their definition
                            Marking an interface private, protected, or final will trigger a compiler error 
                    5. ALL nondefault methods in an interface are assumed to have the modifiers abstract and public in their definition 
                            Marking a method as private, protected, or final will trigger a compiler error 
                    ** the 4th rule does NOT apply to inner interfaces
            ->-> Examples::
                  - public interface WalksOnTwoLegs {}

                    public class TestClass {
                      public static void main(String[] args) {
                        WalksOnTwoLegs example = new WalksOnTwoLegs(); // DOES NOT COMPILE because you CANNOT instantiate an interface directly
                      }
                    }
                    
                    public final interface WalksOnEightLegs { // DOES NOT COMPILE because you CANNOT mark interfaces as final
                    }
                  
                  - public interface CanFly {
                        void fly(int speed);
                        abstract void takeoff();
                        public abstract double dive();
                    }
                    
                    [These two interfaces are equivalent]
                    
                    public abstract interface CanFly { 
                        public abstract void fly(int speed);
                        public abstract void takeoff();
                        public abstract double dive();
                    }
                  
                  - private final interface CanCrawl { // DOES NOT COMPILE because interfaces CANNOT be marked final nor private 
                        private void dig(int depth); // DOES NOT COMPILE because ALL interface methods are assumed to be public 
                        protected abstract double depth(); // DOES NOT COMPILE because ALL interface methods are assumed to be public 
                        public final void surface(); // DOES NOT COMPILE because interface methods are assumed to be abstract, marking it final throws a compiler error
                    } 
        Inheriting an Interface ::
            ->-> 2 Important inheritance rules when being extended::
                    1. An interface that extends another interface, as well as an abstract class that implements an interface,
                            inherits ALL of the abstract methods as its OWN abstract methods 
                    2. The FIRST concrete class that implements an interface, or extends an abstract class that implements an interface,
                            MUST provide an implementation for all of the inherited abstract methods 
            ->-> Examples:: 
                 - public interface HasTail {
                    public int getTailLength();
                   }
                   
                   public interface HasWhiskers {
                    public int getNumberOfWhiskers();
                   }
                   
                   public interface Seal extends HasTail, HasWhiskers {
                   }
                 
                 - public interface HasTail {
                     public int getTailLength();
                   }
                   
                   public interface HasWhiskers {
                     public int getNumberOfWhiskers();
                   }
                   
                   public abstract class HarborSeal implements HasTail, HasWhiskers {
                   }
                   
                   public class LeopardSeal implements HasTail, HasWhiskers { // DOES NOT COMPILE because it does NOT privide an implementation for the interface methods 
                   }
        Classes, Interfaces, and Keywords ::
            ->-> A class can implement an interface BUT it CANNOT extend an interface 
            ->-> An interface can extend another interface BUT it CANNOT implement another interface 
            ->-> Examples::
                - public interface CanRun {}
                  
                  public class Cheetah extends CanRun {} // DOES NOT COMPILE because classes CANNOT extend interfaces
                  
                  public class Hyena {}
                  
                  public interface HasFur extends Hyena {} // DOES NOT COMPILE because interfaces CANNOT extend classes 
        Abstract Methods and Multiple Inheritance ::
            ->-> The compiler will throw an exception if you define an interface or abstract class that inherits from two conflicting interfaces 
            ->-> Examples ::
                - Dealing with inheriting from two interfaces with the same abstract method 
                  public interface Herbivore {
                    public void eatPlants();
                  }
                  
                  public interface Omnivore {
                    public void eatPlants(); 
                    public void eatMeat();
                  }

                  public class Bear implements Herbivore, Omnivore {
                    public void eatMeat() {
                      System.out.println("Eating meat");
                    }
                    public void eatPlants() { // this works because if an interface's method shares the same signature, 
                                              //    providing implementation for one is the same as providing implementation for both
                      System.out.println("Eating plants");
                    }
                  }

                - Dealing with two methods having different signatures (method overloading)
                  public interface Herbivore {
                    public int eatPlants(int quantity);
                  }
                  
                  public interface Omnivore {
                    public void eatPlants();
                  }
                  
                  public class Bear implements Herbivore, Omnivore {
                    public int eatPlants(int quantity) {            // still has to provide implementation for both methods regardless of overload or not
                        System.out.println("Eating plants: "+quantity);
                        return quantity;
                    }
                    public void eatPlants() {               // still has to provide implementation for both methods regardless of overload or not
                        System.out.println("Eating plants");
                    }
                  }
                
                - public interface Herbivore {
                    public int eatPlants();
                  }
                
                  public interface Omnivore {
                    public void eatPlants();
                  }
                
                  public class Bear implements Herbivore, Omnivore {
                    public int eatPlants() { // DOES NOT COMPILE because it is not possible to define 
                                             //    two methods in a class with the same name and input parameters but different return types 
                        System.out.println("Eating plants: 10");
                        return 10;
                    }
                    public void eatPlants() { // DOES NOT COMPILE because of the same reason as the other one
                        System.out.println("Eating plants");
                    }
                  }
                
                - public interface Herbivore {
                    public int eatPlants();
                  }
                
                  public interface Omnivore {
                    public void eatPlants();
                  }
                
                  public interface Supervore extends Herbivore, Omnivore {} // DOES NOT COMPILE because the extending interfaces interfere with each other (conflict) 
                
                  public abstract class AbstractBear implements Herbivore, Omnivore {} // DOES NOT COMPILE (same reason as the other DOES NOT COMPILE)
        Interface Variables ::
            ->-> Two interface Variable Rules ::
                    1. Interface variables are assumed to be public, static, and final; marking one as private, protected, or abstract will trigger a compiler error
                    2. The value of an interface variable MUST be set when it is declared since it is marked as final
            ->-> Examples ::
                  - public interface CanSwim {
                       int MAXIMUM_DEPTH = 100;
                       final static boolean UNDERWATER = true;
                       public static final String TYPE = "Submersible";
                    }
                    [equivalent]
                    public interface CanSwim {
                       public static final int MAXIMUM_DEPTH = 100;
                       public static final boolean UNDERWATER = true;
                       public static final String TYPE = "Submersible";
                    }

                  - public interface CanDig {
                      private int MAXIMUM_DEPTH = 100; // DOES NOT COMPILE because of the private access modifier 
                      protected abstract boolean UNDERWATER = false; // DOES NOT COMPILE because of the protected and abstract modifiers 
                      public static String TYPE; // DOES NOT COMPILE because a value is missing 
                    }
        Default Interface Methods ::
            ->-> A default method is a method defined within an interface with the default keyword in which a method boy is provided
            ->-> A default method, within an interface, defines an abstract method with a default implementation; 
                    this means that classes have the option to override the default method if they need to
            ->-> default interface method rules:: 
                  1. A default method may only be declared within an interface and NOT within a class or abstract class 
                  2. A default method must be marked with the default keyword;
                        if a method is marked as default, it must provide a method body
                  3. A default method is NOT assumed to be static, final, nor abstract, as it may be used or overridden by a class that implements the interface 
                  4. A default method is assumed to be public and will NOT compile if marked as private or protected 
            ->-> default methods CANNOT be marked static, final, nor abstract and require an instance of the class implementing the interface to be invoked 
            ->-> When an interface extends another interface that contains a default method, it can choose to ignore the default method,
                    allowing the default implementation for the method to be used 
            ->-> The interface may override the definition of the default method (method overriding rules)
            ->-> The interface may redeclare the method as abstract, requiring classes that implement the new interface to explicitly provide a method body
            ->-> Examples ::
                  - public interface IsWarmBlooded {
                      boolean hasScales(); // normal abstract method, assumed public 
                      public default double getTemperature() { // default method (notice it is given implementation)
                        return 10.0;
                      }
                    }
                
                  - public interface Carnivore {
                      public default void eatMeat(); // DOES NOT COMPILE because it is marked as default but does NOT provide a method body 
                      public int getRequiredFoodAmount() { // DOES NOT COMPILE because it provides a method body BUT is not marked as default 
                        return 13;
                      }
                    }
                
                  - overrides on default interface method and redeclares a second interface method as abstract 
                    public interface HasFins {
                      public default int getNumberOfFins() {
                        return 4;
                      }
                      public default double getLongestFinLength() {
                        return 20.0;
                      }
                      public default boolean doFinsHaveScales() {
                        return true;
                      }
                    }
                    
                    public interface SharkFamily extends HasFins {
                      public default int getNumberOfFins() {
                        return 8;
                      }
                      public double getLongestFinLength();
                      public boolean doFinsHaveScales() { // DOES NOT COMPILE because interfaces may only contain methods with a body that are marked as default
                        return false;
                      }
                    }
        Default Methods and Multiple Inheritance ::
            ->-> If a class implements two interfaces that have default methods with the SAME name and signature,
                        the compiler will throw an error 
                    **** Exception to this rule is if the subclass overrides the duplicate default methods
            ->-> Examples ::
                  - public interface Walk {
                      public default int getSpeed() {
                        return 5;
                      }
                    }
                    
                    public interface Run {
                      public default int getSpeed() {
                        return 10;
                      }
                    }
                    
                    public class Cat implements Walk, Run { // DOES NOT COMPILE because you confuse the compiler by giving it two implementations for the same method signature, 
                                                            //   making it unknown which value to use, 5 or 10
                      public static void main(String[] args) {
                        System.out.println(new Cat().getSpeed());
                      }
                    }

                  - public class Cat implements Walk, Run { // same interface set up as the previous example 
                      public int getSpeed() { // overrides the getSpeed() method by providing its own implementation 
                        return 1;
                      }
                      public static void main(String[] args) {
                        System.out.println(new Cat().getSpeed());
                      }
                    }
        Static Interface Methods ::
            ->-> static methods in interfaces are method defined explicitly with the static keyword and function NEARLY identical to static methods defined in classes
            ->-> static interface method rules ::
                    1. A static method in an interface is assumed to be public and will NOT compile if marked as private or protected 
                    2. To reference the static method, a reference to the name of the interface must be used 
            ->-> A class that implements two interfaces containing static methods with the SAME signature will STILL compile at runtime,
                    due to the fact that static methods are NOT inherited by the subclass and       
                        MUST be accessed with a reference to the interface name 
            ->-> Static interface methods have NONE of the same multiple inheritance rules as default interface methods do 
            ->-> Examples ::
                  - public interface Hop {
                      static int getJumpHeight() {
                        return 8;
                      }
                    }
                    // can be accessed using Hop.getJumpHeight() syntax
                    ** the compiler automatically inserts the access modifier public 
                  
                  - implementing Hop() (incorrectly)
                    public class Bunny implements Hop {
                      public void printDetails() {
                        System.out.println(getJumpHeight()); // DOES NOT COMPILE because there is no explicit reference to the name of the interface
                      }
                    }
    Understanding Polymorphism ::
            ->-> polymorphism is the property of an object to take on many different forms 
            ->-> In Java, polymorphism shown in how a Java object may be accessed by::
                         using a reference with the same type as the object, 
                         a reference that is a superclass of the object, or
                         a reference that defines an interface the object implements, either directly or through a superclass 
            ->-> A cast is NOT required if the object is being reassigned to a super type or interface of the object 
            ->-> Examples ::
                  - public class Primate {
                      public boolean hasHair() {
                        return true;
                      }
                    }
                    
                    public interface HasTail {
                      public boolean isTailStriped();
                    }
                    
                    public class Lemur extends Primate implements HasTail {
                      public boolean isTailStriped() {
                        return false;
                      }
                      public int age = 10;
                      public static void main(String[] args) {
                        Lemur lemur = new Lemur();
                        System.out.println(lemur.age); // outputs 10
                       
                        HasTail hasTail = lemur;
                        System.out.println(hasTail.isTailStriped()); // outputs false
                        
                        Primate primate = lemur;
                        System.out.println(primate.hasHair()); // outputs true; 
                      }
                    }
                    ** most important take away is that only one object, Lemur, is created and referenced but has the properties of the HasTail and Primate classes **

                  - HasTail hasTail = lemur; // keeping the assumption that these are the same classes and implementations as the previous example 
                    System.out.println(hasTail.age); // DOES NOT COMPILE because only Lemur has access to age, 
                                                     //   while the hasTail reference is being assigned to the lemur reference, 
                                                     //     it still ONLY has access to the HasTail variables and methods  
                    Primate primate = lemur;
                    System.out.println(primate.isTailStriped()); // DOES NOT COMPILE because while the primate reference is being assigned to the lemur reference, 
                                                                 //   it still ONLY has access to the Primate variables and methods 
        Object vs. Reference ::
            ->-> Two IMPORTANT rules ::
                1. The type of the object determines which properties exist within the object in memory
                2. The type of the reference to the object determines which methods and variables are accessible to the Java program 
            ->-> You can "reclaim" access to the variables of the original class 
                    (if, like in the example, you go from a Lemur to an Object) by explicitly casting your reference BACK to that type 
            ->-> Examples ::
                  - Lemur lemur = new Lemur();
                    
                    Object lemurAsObject = lemur;
                   *** Explanation of what this does***
                     ** The Lemur object has been assigned a reference with a different type BUT 
                            the object itself has not changed and still exists as a Lemur object in memory.
                          What has changed is the ability to access methods within the Lemur class with the lemurAsObject reference;
                                without an explicit cast BACK to Lemur, lemurAsObject no longer has access to the Lemur properties of the object
        Casting Objects ::
            ->-> Rules when casting variables::
                  1. Casting an object from a subclass to a superclass does NOT require an explicit cast *
                  2. Casting an object from a superclass to a subclass DOES require an explicit cast *
                  3. The compiler will NOT allow casts to unrelated types 
                  4. An exception may be thrown at runtime if the object being cast is NOT actually an instance of that class even if the code compiles without an issue
                  * think of it like -> small to large does NOT require a cast BUT large to small DOES require an explicit cast 
            ->-> Examples ::
                  - Primate primate = lemur;
                    Lemur lemur2 = primate; // DOES NOT COMPILE because there is no explicit cast; therefore, 
                                            //   NOT allowing the primate reference back to a lemur reference 
                    
                    Lemur lemur3 = (Lemur)primate;
                    System.out.println(lemur3.age);
                 
                  - public class Bird {}
                    
                    public class Fish {
                      public static void main(String[] args) {
                        Fish fish = new Fish();
                        Bird bird = (Bird)fish; // DOES NOT COMPILE because Fish and Bird are NOT related through any class hierarchy
                                                //     Fish is not a subclass of Bird 
                      }
                    }
                 
                  - public class Rodent {}
                    
                    public class Capybara extends Rodent {
                      public static void main(String[] args) {
                        Rodent rodent = new Rodent();
                        Capybara capybara = (Capybara)rodent; // Throws ClassCastException at runtime*
                      }
                    }
                    * it throws this because the object being referenced is NOT an instance of the Capybara class 
        Virtual Methods ::
            ->-> A virtual method is a method in which the specific implementation is not determined until runtime
            ->-> ALL NON-final NON-static, and NON-private Java methods are considered virtual methods, since they can be overridden at runtime 
            ->-> If you call a method on an object that overrides a method, you get the overriden method, 
                    regardless of if the call to the method is on a parent reference or within the parent class 
            ->-> Examples ::
                  - public class Bird {
                      public String getName() {
                        return "Unknown";
                      }
                      public void displayInformation() {
                        System.out.println("The bird name is: "+getName());
                      }
                    }
                    
                    public class Peacock extends Bird {
                      public String getName() {
                        return "Peacock";
                      }
                      public static void main(String[] args) {
                        Bird bird = new Peacock();
                        bird.displayInformation(); // this method displays   The bird name is: Peacock 
                      }
                    }
        Polymorphic Parameters ::
            ->-> Examples ::
                  - public class Reptile {
                      public String getName() {
                        return "Reptile";
                      }
                    }
                    
                    public class Alligator extends Reptile {
                      public String getName() {
                        return "Alligator";
                      }
                    }
                    
                    public class Crocodile extends Reptile {
                      public String getName() {
                        return "Crocodile";
                      }
                    }
                    
                    public class ZooWorker {
                      public static void feed(Reptile reptile)* {
                        System.out.println("Feeding reptile "+reptile.getName());
                      }
                      public static void main(String[] args) {
                        feed(new Alligator()); 
                        feed(new Crocodile());
                        feed(new Reptile());
                      }
                    }
                    // the output of this is ::
                        Feeding: Alligator 
                        Feeding: Crocodile
                        Feeding: Reptile 
                    * Even though the method's parameter must take in a Reptile, 
                        since Alligator and Crocodile are subclasses of Reptile, there are no exceptions (they are related to reptile)
            ->-> Polymorphic Parameters and Code Reusability ::
                    If you are defining a method that will be accessible outside the current class,
                        either to subclasses of the current class or publicly to objects outside the current class, 
                            it is considered good coding practice to use the superclass or interface type of input parameters whenever possible
    Exam Essentials ::
        ->-> Be able to write code that extends other classes 
        ->-> Understand the rules for method overriding 
        ->-> Understand the rules for hiding methods and variables 
        ->-> Recognize the difference between method overriding and method overloading 
        ->-> Be able to write code that creates and extends abstract classes 
        ->-> Be able to write code that creates, extends, and implements interfaces
        ->-> Be able to write code that usese default and static interface methods 
        ->-> Understand polymorphism 
        ->-> Recognize valid reference casting 
Chapter 6 [Exceptions]::
    PDF Page: 345
    Understanding Exceptions ::
            ->-> Possibilities for a program to fail:
                 - The code tries to connect to a website, but the Internet connection is down 
                 - You made a coding mistake and tried to access an invalid index in an array 
                 - One method calls another with a value that the method does NOT support  
        The Role of Exceptions ::
            ->-> An exception is just Java's way of saying it has no idea what to do now
            ->-> Exception alter the program flow 
        Understanding Exception Types ::
            ->-> Java has a Throwable superclass for all objects
            ->-> Categories of exception 
                        java.lang.Object at the very top

                        java.lang.Throwable right below it 
                
                java.lang.Exception     and         java.lang.Error  underneath Throwable

                        and 
            
                java.lang.RuntimeException underneath the Exception
            ->-> Error means something went horribly wrong (exaggeration ish) 
                        ie.) the disk drive "disappeared" 
            ->-> A runtime exception tends to be unexpected a.k.a unchecked exceptions
                        ie.) accessing an invalid array index 
            ->-> *When you see runtime, it means unchecked*
            ->-> A checked exception tend to be more anticipated 
                        ie.) trying to read a file that does NOT exist 
            ->-> Java has a rule called the handle or decalre rule, 
                    meaning Java requires the code to either handle them or decalre them in the method signature
            ->-> Examples ::
                  - void fall() throws Exception {
                        throw new Exception(); 
                    }
                    * throw tells Java that you want to throw an Exception
                    * throws simply declares that the method MIGHT throw an Exception 
        Throwing an Exception ::
            ->-> You might encounter an exception that was made up for the exam 
            ->-> One way you'll see code the result in an exception is that it is wrong 
                    ie.) String[] animals = new String[0];
                         System.out.println(animals[0]); // throws an ArrayIndexOutOfBoundsException
            ->-> Another way for code to result in an exception is to explicitly request Java to throw one 
            ->-> When creating an exception, you can USUALLY pass a String parameter with a message or no parameters and use the defaults 
                    (usually because this is a Java convention)
            ->-> Types of Exceptions::
                  Type                How to recognize               Okay for program to catch?        Is program required to hand or declare? 
                  Runtime Exception   Subclass of RuntimeException   Yes                               No 
                 
                  Checked Exception   Subclass of Exception BUT      Yes                               Yes 
                                      NOT subclass of 
                                      RuntimeException
                  Error               Subclass of Error              No                                No 
                                
            ->-> Examples::
                  - throw new Exception();
                  - throw new Exception("Ow! I fell.");
                  - throw new RuntimeException();
                  - throw new RuntimeException("Ow! I fell.");
    Using a try Statment ::
            ->-> A try statement separates the logic that might throw an exception from the logix to handle that exception 
            ->-> Syntax of a try statement::
                  try{         // curly braces are required, the try keyword
                        // the try block aka protected code 
                  } catch(exception_type identifier){    // catch keyword, the type of exception that is trying to be caught
                        // exception handler
                  }
            ->-> The code in the try block is run normally, BUT 
                  if any of the statements throw an exception that can be caught by the exception type listed in the catch block, 
                     the try block stops running and execution goes to the catch statement 
            ->-> If none of the statements in the try block throw an exception that can be caught, the catch clause is NOT run 
            ->-> Examples ::
                  - try // DOES NOT COMPILE because the curly braces, {}, are missing to enclose fall() and System.out.println("get up")
                      fall();
                    catch (Exception e)
                      System.out.println("get up");
                  
                  -  try {// DOES NOT COMPILE because there is not catch block afterwards
                      fall();
                    }
        Adding a finally Block ::
          ->-> the finally block goes AFTER the catch block 
                ie.) try{

                     }catch (someException){

                     }finally{

                     }
          ->-> the finally block ALWAYS runs regardless of there is a caught exception or not 
          **** Exception to the "finally block ALWAYS runs" is when the System.exit(0) method is called (it ends the program immediately),
                  When it is called in the try or catch block, finally will NOT run 
          ->-> Examples ::
                - 25: try { // DOES NOT COMPILE because the catch and finally blocks are swapped 
                  26:   fall();
                  27: } finally {
                  28:   System.out.println("all better");
                  29: } catch (Exception e) {
                  30:   System.out.println("get up");
                  31: }
                  32:
                  33: try { // DOES NOT COMPILE because there is no catch block 
                  34: fall();
                  35: }
                  36:
                  37: try { // this one works because catch is not required if finally is present 
                  38:   fall();
                  39: } finally {
                  40:   System.out.println("all better");
                  41: }
        Catching Various Types of Exceptions ::
          ->-> You must be able to recognize if the exception is a checked or an unchecked exception
          ->-> You need to determine if any of the exception are subclasses of others 
          ->-> You can have multiple catch statements 
          ->-> Java looks at catch blocks in the order they appear
          ->-> If it is impossible for one of the catch blocks to be executed, a compiler error happens
                  This happens when a superclass is caught before a subclass 
          ->-> Examples ::
                - public void visitMonkeys() {
                    try {
                      seeAnimal();
                    } catch (ExhibitClosed e) {
                        System.out.print("not today");
                    } catch (ExhibitClosedForLunch e) {// DOES NOT COMPILE because the broader exception if in the catch block above it 
                                                       //    making it impossible for the more specific ExhibitClosedForLunch exception to be caught 
                        System.out.print("try back later");
                    }
                  }
        Throwing a Second Exception ::
          ->-> All that really you need to know from this is that you can throw multiple exceptions within a try-catch-finally block 
          ->-> Examples ::
               - 30: public String exceptions() {
                 31:  String result = "";
                 32:  String v = null;
                 33:  try {
                 34:    try {
                 35:      result += "before";
                 36:      v.length();
                 37:      result += "after";
                 38:    } catch (NullPointerException e) {
                 39:     result += "catch";
                 40:     throw new RuntimeException();
                 41:    } finally {
                 42:     result += "finally";
                 43:     throw new Exception();
                 44:    }
                 45:  } catch (Exception e) {
                 46:    result += "done";
                 47:  }
                 48:  return result;
                 49: }
                 // the output is     before catch finally done
    Recognizing Common Exception Types ::
        Runtime Exceptions ::
              - ArithmeticException:: Thrown by the JVM when code attempts to divide by zero 
                      ie.) int answer = 11/0; 
                          - results in having this output     Exception in thread "main" java.lang.ArithmeticException: / by zero
              - ArrayIndexOutOfBoundsException: Thrown by the JVM when code uses an illegal index to access an array 
                      ie.) int[] countsOfMoose = new int[3];
                           System.out.println(countsOfMoose[-1]);
                           - results in having this output    Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: -1
              - ClassCastException: Thrown by the JVM when an attempt is made to cast an exception to a subclass of which it is not an instance 
                      ie.) String type = "moose"; 
                           Integer number = (Integer) type; // DOES NOT COMPILE 
                           - results in having this output    
                                            Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
              - IllegalArgumentException: Thrown by the programmer to indicate that a method has been passed an illegal or inappropriate argument 
                      ie.) public static void setNumberEggs(int numberEggs) {
                             if (numberEggs < 0)
                              throw new IllegalArgumentException(
                                "# eggs must not be negative");
                             this.numberEggs = numberEggs;
                           }
                           - results in having this output     Exception in thread "main" java.lang.IllegalArgumentException: # eggs must not be negative
              - NullPointerException: Thrown by the JVM when there is a null reference where an object is required 
                      ie.) String name; 
                           public void printLength() throws NullPointerException {
                              System.out.println(name.length());
                           }
                           - results in having this output     Exception in thread "main" java.lang.NullPointerException
              - NumberFormatException: Thrown by the programmer when an attempt is made to convert a string to a numeric type 
                                                    BUT the string does NOT have an appropriate format
                      ie.) Integer.parseInt("abc");
                           - results in having this output     Exception in thread "main" java.lang.NumberFormatException: For input string: "abc"
        Checked Exceptions ::
              - FileNotFoundException: Thrown programmatically when code tries to reference a file that does NOT exist 
                            this is a subclass of IOException
              - IOException: Thrown programmatically when there's a problem reading or writing a file 
        Errors ::
              - ExceptionInInitializerError: Thrown by the JVM when a static initializer throws an exception and does NOT handle it 
                      ie.) static {
                             int[] countsOfMoose = new int[3];
                             int num = countsOfMoose[-1];
                           }
                           public static void main(String[] args) { }
                           - results in having this output     Exception in thread "main" java.lang.ExceptionInInitializerError
                                                               Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
              - StackOverflowError: Thrown by the JVM when a method calls itself too many times (aka infinte recursion)
                      ie.) public static void doNotCodeThis(int num) {
                              doNotCodeThis(1);
                           }
                           - results in having this output     Exception in thread "main" java.lang.StackOverflowError
              - NoClassDefFoundError: Thrown by the JVM when a class that the code uses is available at compile time but not runtime 
                    This will not show up in code for the exam, BUT you do need to know it is an error
    Calling Methods That Throw Exceptions ::
          ->-> Checked exception MUST be handled or declared
          ->-> Examples::
                - public class Bunny {
                    public static void main(String[] args) {
                      eatCarrot();// DOES NOT COMPILE
                    }
                    private static void eatCarrot() throws NoMoreCarrotsException {
                    }
                  }

                  this code could compile if the main() method is changed to either 
                    - public static void main(String[] args)
                        throws NoMoreCarrotsException {// declare exception
                        eatCarrot();
                      }
                    or
                    - public static void main(String[] args) {
                        try {
                          eatCarrot();
                        } catch (NoMoreCarrotsException e ) {// handle exception
                          System.out.print("sad rabbit");
                        }
                      }
                - public void bad() {
                    try {
                      eatCarrot();
                    } catch (NoMoreCarrotsException e ) {// DOES NOT COMPILE because Java knows that eatCarrot() CANNOT throw a checked exception 
                                                         //     meaning there is no way for the catch block in bad() to be reached
                      System.out.print("sad rabbit");
                    }
                  }
                  public void good() throws NoMoreCarrotsException {
                    eatCarrot();
                  }
                  private static void eatCarrot() { }
        Subclasses ::
          ->-> When a class overrides a method from a superclass OR implements a method from an interface
                  it is not allowed to add new checked exceptions to the method signature 
          ->-> A subclass is allowed to declare FEWER exceptions than the superclass or interface 
          ->-> A subclass NOT declaring an exception is similar to a method declaring it throws an exception that it never actually throws
          ->-> A class IS allowed to declare a subclass of an exception type 
          ->-> It is okay to declare new runtime exceptions in a subclass method if the declaration is redundant 
          ->-> Methods are free to throw any runtime exceptions they want without mentioning them in the method declaration 
          ->-> Examples::
                - class Hopper {
                    public void hop() { }
                  }
                  class Bunny extends Hopper {
                    public void hop() throws CanNotHopException { } // DOES NOT COMPILE because hop is not allowed to throw any checked exceptions 
                                                                    //   because the superclass, Hopper, does NOT declare any exceptions 
                  }
        Printing an Exception ::
          ->-> Three ways to print an exception::
                - Java can print it out 
                - print just the message
                - print where the stack trace comes from 
          ->-> Real World Scenario: Why Swallowing Exception Is Bad :: 
                  Because checked exceptions require you to handle or declare them, 
                    there is a temptation to catch them so they “go away” 
                      BUT doing so can cause problems
                      In the following code, there’s a problem reading in the file:
                       - public static void main(String[] args) {
                         String textInFile = null;
                         try {
                          readInFile();
                         } catch (IOException e) {
                            // ignore exception
                         }
                            // imagine many lines of code here
                            System.out.println(textInFile.replace(" ", ""));
                         }
                        private static void readInFile() throws IOException {
                            throw new IOException();
                        }
                  The code results in a NullPointerException
                    Java doesn’t tell you anything about the original IOException because it was handled
                      When writing your own code, print out a stack trace or at least a message when catching an exception
                       Consider whether continuing is the best course of action
                        In our example, the program can’t do anything after it fails to read in the file
                         It might as well have just thrown the IOException
          ->-> Examples ::
                - 5: public static void main(String[] args) {
                  6:  try {
                  7:   hop();
                  8:   } catch (Exception e) {
                  9:      System.out.println(e);
                  10:     System.out.println(e.getMessage());
                  11:     e.printStackTrace();
                  12:   }
                  13: }
                  14: private static void hop() {
                  15:   throw new RuntimeException("cannot hop");
                  16: }

                  // the output is as follows::
                  // 
                  // java.lang.RuntimeException: cannot hop // shows what java prints 
                  // cannot hop                             // shows just the message 
                  // java.lang.RuntimeException: cannot hop // this down shows the stack trace
                  // at trycatch.Handling.hop(Handling.java:15)
                  // at trycatch.Handling.main(Handling.java:7)
    Exam Essentials ::
      ->-> Differentiate between checked and unchecked exceptions 
      ->-> Understand the flow of a try statement 
      ->-> Identify whether an exception is thrown by the programmer or the JVM 
      ->-> Decalre methods that declare exceptions 
      ->-> Recognize when to use throw versus throws 